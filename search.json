[{"title":"tensorflow-gpu installation","url":"/2019/10/05/GPU%E5%8A%A0%E9%80%9F%E7%89%88TensorFlow%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"GPU加速版TensorFlow安装踩坑记录\"><a href=\"#GPU加速版TensorFlow安装踩坑记录\" class=\"headerlink\" title=\"GPU加速版TensorFlow安装踩坑记录\"></a>GPU加速版TensorFlow安装踩坑记录</h2><p>System information:</p>\n<ul>\n<li><p>Ubuntu 18.04 LTS</p>\n</li>\n<li><p>TensorFlow version: 1.13</p>\n</li>\n<li><p>Python version: 3.6</p>\n</li>\n<li><p>CUDA: 10.0</p>\n</li>\n<li><p>cuDNN: 7.4</p>\n</li>\n<li><p>GPU: Nvidia GeForce GTX 1050</p>\n</li>\n</ul>\n<ol>\n<li><p>千万提前确定好需要使用的tensorflow版本，再下载版本匹配的CUDA, cuDNN</p>\n<p>幸好TensorFlow已经帮我们测试好了，在官网可以轻松找到推荐的<a href=\"https://www.tensorflow.org/install/source#tested_build_configurations\">构建配置</a>。因为我平时都在用Ubuntu18.04，在这把Linux平台上合适的配置放出来</p>\n<p><img src=\"/../images/TensorFlow-linux-%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE.png\" alt=\"Linux平台构建配置\"></p>\n</li>\n<li><p>确定好构建配置，这一步可以<a href=\"https://developer.nvidia.com/cuda-toolkit-archive\">下载CUDA</a>和<a href=\"https://developer.nvidia.com/rdp/cudnn-archive\">cuDNN</a>了</p>\n<p>CUDA安装指令在官网已经详细贴出来，我就不再重复（真正的坑在安装cuDNN的时候等着呢）</p>\n<p><a href=\"https://docs.nvidia.com/deeplearning/sdk/cudnn-install/index.html#installlinux\">安装cuDNN</a>（这里还是以Linux平台为例）：</p>\n<ul>\n<li><p>下载cuDNN需要先注册</p>\n</li>\n<li><p>解压tar包，先修改tar包文件权限</p>\n<p><code>$sudo chmod +x cudnn-10.0-linux-x64-v7.4.2.tgz</code></p>\n<p><code>$tar -xzvf cudnn-10.0-linux-x64-v7.4.2.24.tgz</code></p>\n</li>\n<li><p>复制下列文件到CUDA Toolkit的文件夹，修改这些文件权限</p>\n<p>一般CUDA Toolkit会自动安装在<code>/usr/local</code>下面</p>\n<p><code>$sudo cp cuda/include/cudnn.h /usr/local/cuda/include</code></p>\n<p><code>$sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64</code></p>\n<p><code>$sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</code></p>\n</li>\n</ul>\n</li>\n<li><p>全部安装好后，检查版本是否正确</p>\n<ul>\n<li><p>CUDA版本</p>\n<p><code>$cat /usr/local/cuda/version.txt</code> 或者<code>nvcc --version</code></p>\n</li>\n<li><p>cuDNN版本</p>\n<p><code>$cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</code></p>\n<p>ps: 有时候遇到<code>failed call to cuInit: CUDA_ERROR_UNKNOWN: unknown error</code>需要重启电脑</p>\n</li>\n</ul>\n</li>\n<li><p>最后的最后，检查TensorFlow是否能使用GPU加速</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> tensorflow.python.client <span class=\"keyword\">import</span> device_lib</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># list the avilable devices in local processes</span></span><br><span class=\"line\">device_lib.list_local_devices()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># matrix multiplying with GPU</span></span><br><span class=\"line\">a = tf.constant([<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">6.0</span>], shape=[<span class=\"number\">2</span>, <span class=\"number\">3</span>], name=<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">b = tf.constant([<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">6.0</span>], shape=[<span class=\"number\">3</span>, <span class=\"number\">2</span>], name=<span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\">c = tf.matmul(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">sess = tf.Session(config=tf.ConfigProto(log_device_placement=<span class=\"literal\">True</span>))</span><br><span class=\"line\">print(sess.run(c))</span><br></pre></td></tr></table></figure></li>\n</ol>\n","tags":["tensorflow"]},{"title":"RMQ-ST-table","url":"/2020/11/19/RMQ-ST-table/","content":"<h1 id=\"Range-Minimum-Maximum-Query-RMQ\"><a href=\"#Range-Minimum-Maximum-Query-RMQ\" class=\"headerlink\" title=\"Range Minimum/Maximum Query (RMQ)\"></a>Range Minimum/Maximum Query (RMQ)</h1><p>RMQ对于给定长度n的数列A，询问区间数列A在（i,j）内最大最小值。</p>\n<p>解决方法：（A长度为n，q次查询）</p>\n<ol>\n<li>搜索    复杂度：O(n) - O(qn)</li>\n<li>线段树   预处理：O(n) - 查询：O(qlogn)</li>\n<li>Sparse table(ST) 预处理：O(nlogn) - 查询：O(q)</li>\n</ol>\n<h2 id=\"ST算法\"><a href=\"#ST算法\" class=\"headerlink\" title=\"ST算法\"></a>ST算法</h2><p>ST本质上是动态规划，适用的情况是数据不更新，因为更新需要重新建表，这种情况下就选择线段树啦。</p>\n<p>复杂度：建表O(nlogn)，查询O(1)</p>\n<h3 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h3><p><code>f[i][j]</code>保存每一块[i, i + $2^j$ - 1]的最大值，起点i、终点i + $2^j$ - 1共$2^j$个数</p>\n<p>[i, i + $2^j$ - 1]可以拆分成等长的2块，[i, i + $2^{j-1}$ - 1]和[i + $2^{j-1}$, i + $2^j$ - 1]，递归结构显现，可以用DP啦</p>\n<p><code>f[i][j]=max(f[i][j - 1], f[i + (1&lt;&lt;(j-1))][j - 1])</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// j上限设为20</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; <span class=\"number\">20</span>; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i + (<span class=\"number\">1</span>&lt;&lt;(j-<span class=\"number\">1</span>)) &lt;= size; i++) &#123;</span><br><span class=\"line\">        dp[i][j] = Math.max(dp[i][j - <span class=\"number\">1</span>], dp[i + (<span class=\"number\">1</span>&lt;&lt;(j-<span class=\"number\">1</span>))][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dp[i][0]</code>记录的是原来数组的值，<code>i</code>从1开始是为了query时候方便，不用再改写成从0开始的index</p>\n<h3 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h3><p>[l, r]区间可以按照[i, i + $2^j$ - 1]的模式划分成2块，[l, l + $2^k$ - 1]和[r - $2^k$ + 1, r]，</p>\n<p>其中k = $\\lfloor log_2(r - l + 1)\\rfloor$ 向下取整</p>\n<p><img src=\"/2020/11/19/RMQ-ST-table/rmq_st_query.png\" alt=\"query示意图\"></p>\n<p>2段小区间长度相等，记为len，证明小区间有重叠：</p>\n<p>$\\lfloor log_2(len)\\rfloor$ &gt;= $log_2(len)$ - 1，所以$2^{\\lfloor log_2(len)\\rfloor}$ &gt;= len/2, 这样2段小区间便有了重叠，保证query操作的正确性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = (<span class=\"keyword\">int</span>) (Math.log(r - l + <span class=\"number\">1</span>) / Math.log(<span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(dp[l][k], dp[r - (<span class=\"number\">1</span>&lt;&lt;k) + <span class=\"number\">1</span>][k]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","tags":["algorithms","dynamic programming"]},{"title":"Binary Expansion","url":"/2020/12/14/binary-expansion/","content":"<h1 id=\"快速幂算法的原理及实现\"><a href=\"#快速幂算法的原理及实现\" class=\"headerlink\" title=\"快速幂算法的原理及实现\"></a>快速幂算法的原理及实现</h1><p>先放代码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pow</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res *= a;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a *= a;</span><br><span class=\"line\">        b &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>快速幂算法的原理是通过将指数拆分成几个因数相乘的形式，来简化幂运算。在我们计算$3^{13}$的时候，普通的幂运算算法需要计算13次，但是如果我们将它拆分成$3^{8+4+1}$，再进一步拆分成 $3^{8}*3^{4}*3^{1}$只需要计算4次。嗯？哪来的4次？，别急，接着看。</p>\n<p>这种拆分思想其实就是借鉴了二进制与十进制转换的算法思想，我们知道13的二进制是1101，可以知道：</p>\n<p>$13 = 1 * 2^{3} + 1 * 2^{2} + 0 * 2^{1} + 1 * 2^{0} = 8 + 4 + 1$</p>\n<p>实现的代码已经给出，原理就是利用位运算里的位移<code>&gt;&gt;</code>和按位与<code>&amp;</code>运算，代码中<code>b &amp; 1</code>其实就是取b二进制的最低位，用来判断最低位是0还是1，再根据是0还是1决定乘不乘，不理解的话联系一下二进制转换的过程。<code>b &gt;&gt;= 1</code>其实就是将b的二进制向右移动一位，就这样位移、取最低位、位移、取最低位，这样循环计算，直到指数b为0为止，整个过程和我们手动将二进制转换成十进制是非常相似的。普通幂算法是需要循环指数次，也就是指数是多少就要循环计算多少次，而快速幂因为利用了位移运算，只需要算“指数二进制位的位数”次，对于13来说，二进制是1101，有4位，就只需要计算4次，快速幂算法时间复杂度是O(logn)级别，对于普通幂需要计算一百万次的$10^{10^{6}}$来说，快速幂只需要计算6次，这是速度上质的飞跃，但是需要多注意溢出的问题。</p>\n<p>转载: <a href=\"https://blog.csdn.net/u014799564/article/details/97623391?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control\">快速幂算法的原理及实现</a></p>\n","tags":["algorithms"]},{"title":"Binary Indexed Tree","url":"/2021/02/23/binary-indexed-tree/","content":"<h1 id=\"Binary-Indexed-Tree\"><a href=\"#Binary-Indexed-Tree\" class=\"headerlink\" title=\"Binary Indexed Tree\"></a>Binary Indexed Tree</h1><p>树状数组（或者直译过来就是：二进制下标树）支持两种操作，时间复杂度均为$O(logn)$</p>\n<ul>\n<li>单点修改：更改数组中的一个元素的值</li>\n<li>区间查询：查询一个区间内所有元素的和</li>\n</ul>\n<p>先放个图，直观感受一下树状数组如何维护数据的</p>\n<p><img src=\"/2021/02/23/binary-indexed-tree/fenwick_tree_8_item.png\" alt=\"8个元素的树状数组\"></p>\n<p>可以看到，树状数组（以下简称BIT）里的$C_i$维护一个小区间。BIT选择的维护的区间长度和i的二进制表示息息相关，从而做到了查询和修改的复杂度都在O(logn)内。借用BIT原始论文中的图来展示数组的$C_i$对应原始数组的哪些项，可以看到一个竖条对应一个$C_{i}$维护的区间，竖条顶端的阴影方块对应的数字就是这个区间累加和存在BIT中相应的下标。</p>\n<p><img src=\"/2021/02/23/binary-indexed-tree/BIT_cumulative_freq_tbl.jpg\" alt=\"fenwick论文树状数组储存的累加值对应的范围\"></p>\n<p>BIT巧妙利用了二进制的表示。例如查询前11项和query(11)，这在BIT中是如何判断该合并那些区间来输出前11项的和呢？先看11的二进制表示$(1011)_2$，在BIT中前11项的和由$((0000)_2, (1000)_2]$，$((1000)_2, (1010)_2]$，$((1010)_2, (1011)_2]$这些区间组成，其中奥秘如下图：</p>\n<p><img src=\"/2021/02/23/binary-indexed-tree/BIT_%E4%B8%8B%E6%A0%87%E5%8C%BA%E9%97%B4%E5%92%8C.png\" alt=\"下标区间\"></p>\n<p>区间下标的变化：<strong>不断移出二进制下标最低位的1</strong></p>\n<p>求二进制最右边的1到末尾的大小（最右边的1和之后的0组成的数字），这里用到了补码的知识。对于$(1011)_2$，先取反得到$(0100)_2$，再加1变成$(0101)_2$，再和原数相加，1011 &amp; 0100，最后得到$(0011)_2$。其中，取反加一，根据补码的知识，可以通过语言中整数取相反数得到。</p>\n<p><strong>lowbit的实现</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x &amp; -x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"单点修改\"><a href=\"#单点修改\" class=\"headerlink\" title=\"单点修改\"></a>单点修改</h2><p>那么更新过程如同在“爬树”，从更新的index沿着下图中的树型结构向ancestor爬，知道超出数组界限。顺便说明一下，树状数组的下标从1开始，tree[0]是不存东西的。比如，原始数组中的3这个位置的数据更新了，那么相应的3-&gt;4-&gt;8-&gt;…都需要更新，正好每次向上爬的index加的正是lowbit(x)</p>\n<p><img src=\"/2021/02/23/binary-indexed-tree/BIT_update_tree.png\" alt=\"树状数组更新\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> inc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t* @param inc increment value for i-th array item</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= MAX_N) &#123;</span><br><span class=\"line\">        tree[i] += inc;</span><br><span class=\"line\">        i += lowbit(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"区间查询\"><a href=\"#区间查询\" class=\"headerlink\" title=\"区间查询\"></a>区间查询</h2><p>区间和的查询过程也有一个树型结构。比如查询前11项的和，初始n=11，沿着树向上，11-&gt;10-&gt;8-&gt;0到0为止，前11项的和=BIT[11] + BIT[10] + BIT[8]。这和之前讲lowbit函数，解释树状数组中区间的下标变化，是一样的过程。</p>\n<p><img src=\"/2021/02/23/binary-indexed-tree/BIT_query_tree.png\" alt=\"树状数组的query tree\"></p>\n<p><strong>前n项前缀和</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * @return the sum of first n items</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        sum += tree[n];</span><br><span class=\"line\">        n -= lowbit(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>区间查询</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * query range sum begins at the specified index l and extends to the index r,</span></span><br><span class=\"line\"><span class=\"comment\">    * range length is (r - l + 1)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (query(r) - query(l - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>有趣的是，树状数组还可以求逆序对，见<strong>（洛谷P1908）逆序对</strong></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://zhuanlan.zhihu.com/p/93795692\">算法学习笔记(2) : 树状数组</a></p>\n<p><a href=\"https://windliang.wang/2020/08/30/%E4%BA%8C%E5%8F%89%E7%B4%A2%E5%BC%95%E6%A0%91%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86/\">二叉索引树（树状数组）的原理</a></p>\n","tags":["data structure"]},{"title":"康托展开","url":"/2020/12/13/cantor-expansion/","content":"<h1 id=\"康托展开\"><a href=\"#康托展开\" class=\"headerlink\" title=\"康托展开\"></a>康托展开</h1><p>简单说：</p>\n<p>给出一个1-n的全排列 -&gt; 问这是第几个排列(字典序), 这是康托展开</p>\n<p>知道全排列长度和字典序 -&gt; 问这个全排列长啥样，这是逆展开</p>\n<p>来自<a href=\"https://zh.wikipedia.org/wiki/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80\">Wikipedia</a>的说明：<strong>康托展开</strong>是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序。</p>\n<p>把1-n的所有排列按字典序排序，这个排列的位次就是它的排名。排列和它的排名是一一对应的，也就是说康托展开是双射，正反过程都是行得通的，才有逆展开。例子可以看<a href=\"https://leetcode-cn.com/problems/permutation-sequence/\">LeetCode 60.排列序列</a>的问题描述，对字典序和逆过程可以直观理解一下。</p>\n<h2 id=\"简单展开\"><a href=\"#简单展开\" class=\"headerlink\" title=\"简单展开\"></a>简单展开</h2><p>$X = a_n(n-1)! + a_{n-1}(n-2)! + … + a_10!$</p>\n<p>一个全排列，第i位有n-1-i种选择。</p>\n<p>比如4321这个全排列，第一个数为4，比4小的选择有{1, 2, 3} 3个数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0   1 2 3 4</span><br><span class=\"line\">1   1 2 4 3</span><br><span class=\"line\">2   1 3 2 4</span><br><span class=\"line\">3   1 3 4 2</span><br><span class=\"line\">4   1 4 2 3</span><br><span class=\"line\">5   1 4 3 2</span><br><span class=\"line\">6   2 1 3 4</span><br><span class=\"line\">7   2 1 4 3</span><br><span class=\"line\">8   2 3 1 4</span><br><span class=\"line\">9   2 3 4 1</span><br><span class=\"line\">10  2 4 3 1</span><br><span class=\"line\">11  2 4 3 1</span><br><span class=\"line\">12  3 1 2 4</span><br><span class=\"line\">13  ...</span><br></pre></td></tr></table></figure>\n\n<p>考虑到后面还有3位（n=3的全排列有3!种），所以开头为4的排列的序号从3*3!开始。首位为k的n阶全排列，它表示的数在从0开始第k个长为(n-1)!的区间，这个区间为[(k-1)*(n-1)!, k*(n-1)!]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0   X 2 3 4  &lt;&#x3D;&#x3D;&gt;  1 2 3</span><br><span class=\"line\">1   X 2 4 3  &lt;&#x3D;&#x3D;&gt;  1 3 2</span><br><span class=\"line\">2   X 3 2 4  &lt;&#x3D;&#x3D;&gt;  2 1 3</span><br><span class=\"line\">3   X 3 4 2  &lt;&#x3D;&#x3D;&gt;  2 3 1</span><br><span class=\"line\">4   X 4 2 3  &lt;&#x3D;&#x3D;&gt;  3 1 2</span><br><span class=\"line\">5   X 4 3 2  &lt;&#x3D;&#x3D;&gt;  3 2 1</span><br><span class=\"line\">6   X 1 3 4  &lt;&#x3D;&#x3D;&gt;  1 2 3</span><br><span class=\"line\">7   X 1 4 3  &lt;&#x3D;&#x3D;&gt;  1 3 2</span><br><span class=\"line\">8   X 3 1 4  &lt;&#x3D;&#x3D;&gt;  2 1 3</span><br><span class=\"line\">9   X 3 4 1  &lt;&#x3D;&#x3D;&gt;  2 3 1</span><br><span class=\"line\">10  X 4 3 1  &lt;&#x3D;&#x3D;&gt;  3 1 2</span><br><span class=\"line\">11  X 4 3 1  &lt;&#x3D;&#x3D;&gt;  3 2 1</span><br><span class=\"line\">12  X 1 2 4  &lt;&#x3D;&#x3D;&gt;  1 2 3</span><br><span class=\"line\">13  ...</span><br></pre></td></tr></table></figure>\n\n<p>上图展示了4阶全排列和3阶全排列的关系，也就是说，去掉第1位后，4阶全排列可以转化为3阶全排列</p>\n<p>公式中的$a_n$可以理解为第n位的数字排在还没使用的数字中第几位（从0开始），或者以$a_n$为前项的逆序对的个数。$a_n$组成的序列也被叫做Lehmer Code。</p>\n<p>例子：</p>\n<p>2314 -&gt; 1100</p>\n<p>14523 -&gt; 02200</p>\n<p>得到的逆序对序列可以当成一个特殊进制的数（第n位对应(n-1)!权重），转换成10进制就是要求的全排列的字典序（别忘了+1）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getOrder</span><span class=\"params\">(<span class=\"keyword\">int</span> n, String permutation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] num = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        num[i] = Integer.valueOf(permutation.charAt(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> inverse = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num[i] &gt; num[j]) &#123;</span><br><span class=\"line\">                inverse++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = res * (n - i) + inverse;</span><br><span class=\"line\">        <span class=\"comment\">// res += res + inverse * factorial[n - 1 - i];</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res + <span class=\"number\">1</span>; <span class=\"comment\">// start at 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逆展开\"><a href=\"#逆展开\" class=\"headerlink\" title=\"逆展开\"></a>逆展开</h2><p>逆展开就是上面字典序到全排列的过程，利用进制转换的代码完成字典序到逆序对序列（相当于10进制转换到以n!为进制的数），在根据逆序个数还原全排列（每次剩下还没使用的数字集合都在改变！）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; bits = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        bits.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] factorial = &#123; <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">24</span>, <span class=\"number\">120</span>, <span class=\"number\">720</span>, <span class=\"number\">5040</span>, <span class=\"number\">40320</span>, <span class=\"number\">362880</span> &#125;;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> residue = k - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> iid = residue / factorial[n - <span class=\"number\">1</span> - i];</span><br><span class=\"line\">        residue = residue % factorial[n - <span class=\"number\">1</span> - i];</span><br><span class=\"line\">        sb.append(bits.get(iid));</span><br><span class=\"line\">        bits.remove(iid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"升级版展开\"><a href=\"#升级版展开\" class=\"headerlink\" title=\"升级版展开\"></a>升级版展开</h2><p>简单版本康托展开使用一个循环来数逆序个数，整体代码的复杂度是O(n^2)。可以改进的地方就在如何更快地数逆序，一种办法可以用分治类比merge sort的代码来计算逆序，复杂度为O(logn)；另外也可以用线段树或者树状数组来统计逆序，复杂度同样为O(logn)。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://zhuanlan.zhihu.com/p/98524232\">迟到的【洛谷日报#187】浅谈康托展开</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/39377593\">【给初心者的】康托展开</a></p>\n","tags":["algorithms"]},{"title":"Git Submodule","url":"/2020/10/10/git-submodule/","content":"<h1 id=\"Git-Submodule\"><a href=\"#Git-Submodule\" class=\"headerlink\" title=\"Git Submodule\"></a>Git Submodule</h1><p>有可能会将代码根据功能拆解成不同的子模块。主项目对子模块有依赖关系，却又并不关心子模块的内部开发流程细节。</p>\n<p>这种情况下，通常不会把所有源码都放在同一个 Git 仓库中。</p>\n<p>有一种比较简单的方式，是在当前工作目录下，将子模块文件夹加入到 <code>.gitignore</code> 文件内容中，这样主项目就能够无视子项目的存在。这样做有一个弊端就是，使用主项目的人需要有一个先验知识：需要在当前目录下放置一份某版本的子模块代码。</p>\n<p>还有另外一种方式可供借鉴，可以使用 Git 的 <code>submodule</code> 功能</p>\n<h3 id=\"1-创建submodule\"><a href=\"#1-创建submodule\" class=\"headerlink\" title=\"1. 创建submodule\"></a>1. 创建submodule</h3><p><code>git submodule add &lt;submodule_url&gt; &lt;directory&gt;</code>在项目中创建一个子模块</p>\n<p>例如：在project目录下<code>git submodule add github.com/username/projectA moduleA</code></p>\n<p>此时主项目仓库会多出两个文件：<code>.gitmodules</code>和<code>moduleA</code>, <code>.gitmodules</code>包含submodule的主要信息</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">[submodule &quot;ModuleA&quot;]</span><br><span class=\"line\">path=moduleA</span><br><span class=\"line\">url=github.com/username/projectA</span><br></pre></td></tr></table></figure>\n\n<p><code>moduleA</code>文件记录子模块的commit id。父项目并不会记录submodule的文件变动，只是按照commit id指定子模块的git HEAD。所以<code>.gitmodules</code>和<code>moduleA</code>都是需要提交到父项目的远程仓库中去的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add .gitmodules moduleA</span><br><span class=\"line\">git commit -m <span class=\"string\">&#x27;add submodule projectA&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-克隆带子模块的repo\"><a href=\"#2-克隆带子模块的repo\" class=\"headerlink\" title=\"2. 克隆带子模块的repo\"></a>2. 克隆带子模块的repo</h3><p>方法一：先clone父项目，再初始化submodule，最后更新submodule。初始化只做一次，之后每次只需要update。默认submodule不在任何分支上，它指向父项目保存的submodule commit id</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> github.com/username/project &amp;&amp; <span class=\"built_in\">cd</span> project</span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br></pre></td></tr></table></figure>\n\n<p>方法二：带上参数<code>--recursive-submodules</code></p>\n<p><code>git clone github.com/username/project --recursive-submodules</code></p>\n<h3 id=\"3-修改submodule\"><a href=\"#3-修改submodule\" class=\"headerlink\" title=\"3. 修改submodule\"></a>3. 修改submodule</h3><p>修改子模块代码只对子模块的版本库产生影响，对父项目的版本库不会产生任何影响。在子项目中修改代码并提交，之后在父项目中便可以看到子项目的新提交，正常add，commit就好。如果父项目需要用到最新版本的子模块，我们需要更新<code>.gitmodules</code>中submodule commit id。</p>\n<h3 id=\"4-更新submodule\"><a href=\"#4-更新submodule\" class=\"headerlink\" title=\"4. 更新submodule\"></a>4. 更新submodule</h3><p>子模块的默认分支不是master</p>\n<p>方法一：先pull父项目，然后执行<code>git submodule update</code>，注意moduleA的分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> project</span><br><span class=\"line\">git pull</span><br><span class=\"line\">git submodule update</span><br></pre></td></tr></table></figure>\n\n<p>方法二：先进入子模块，然后切换到需要的分支，在子模块中pull</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> project/moduleA</span><br><span class=\"line\">git checkout &lt;branch-name&gt;</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">git submodule foreach git pull</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-删除submodule\"><a href=\"#5-删除submodule\" class=\"headerlink\" title=\"5. 删除submodule\"></a>5. 删除submodule</h3><p>先unregister需要删除的子模块，之后可以<code>git-rm</code>移除子模块代码文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> project</span><br><span class=\"line\">git submodule deinit &lt;submodule-name&gt;</span><br><span class=\"line\">git rm &lt;submodule-name&gt;</span><br><span class=\"line\">git commit -m <span class=\"string\">&#x27;delete submodule &lt;submodule-name&gt;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>--force</code>选项会强制删除子模块，即便子模块已经有本地修改</p>\n<p><code>.git/config</code>和<code>.gitmodules</code>中相应内容自动被删除。在之后的<code>git submodule</code>和<code>git submodule foreach</code>都会跳过unregister的子模块</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.cnblogs.com/nicksheng/p/6201711.html\">Git Submodule管理项目子模块</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/87053283\">Git中submodule的使用</a></p>\n<p><a href=\"https://www.cnblogs.com/lsgxeva/p/8540758.html\">Git Submodule使用完整教程</a></p>\n","tags":["Git"]},{"title":"Java中文字符","url":"/2021/04/01/java-char-chinese/","content":"<h1 id=\"Java中的char类型和中文字符\"><a href=\"#Java中的char类型和中文字符\" class=\"headerlink\" title=\"Java中的char类型和中文字符\"></a>Java中的char类型和中文字符</h1><p>开篇发问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Java里的char类型能不能存储一个中文字符？</span><br></pre></td></tr></table></figure>\n\n<p>答案是：可以，但细究起来，并不是简简单单的可以</p>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>对于中文来说，编码方式的使用字节大小各有不同。utf-8：一个中文占用三个字节，utf-16：一个中文占2个字节；gbk(中国人的编码方式)一个汉字2个字节等。Unicode类似一个文字容器，编码方式是一个解码工具，目的是在unicode的字符集中寻找一个对应的字符(我的理解是编码方式是快递员)。众所周知，Unicode有3种编码方式：utf-8, utf-16, utf-32。Unicode标准把代码点分成了17个代码平面（Code Plane），编号为#0到#16。每个代码平面包含65,536（2^16）个代码点（17*65,536=1,114,112）。其中，Plane#0叫做基本多语言平面（Basic Multilingual Plane，BMP），其余平面叫做补充平面（Supplementary Planes）。</p>\n<p>下面是这些平面的名字和用途：</p>\n<p>Plane#0 BMP（Basic Multilingual Plane）大部分常用的字符都坐落在这个平面内，比如ASCII字符，汉字等。<br>Plane#1 SMP（Supplementary Multilingual Plane）这个平面定义了一些古老的文字，不常用。<br>Plane#2 SIP（Supplementary Ideographic Plane）这个平面主要是一些BMP中没有包含汉字。<br>Plane#14 SSP（Supplementary Special-purpose Plane）这个平面定义了一些非图形字符。<br>Plane#15 SPUA-A（Supplementary Private Use Area A）<br>Plane#16 SPUA-B（Supplementary Private Use Area B）</p>\n<h3 id=\"Java中char类型\"><a href=\"#Java中char类型\" class=\"headerlink\" title=\"Java中char类型\"></a>Java中char类型</h3><p>Java中的char类型是按照Unicode规范实现的一种数据类型，固定16bit大小。现如今，Unicode字符集已经进行了扩展，表示的范围已经超过了16bit。Unicode字符集的数值范围扩大到了[U+0000,U+10FFFF]。一个char值可以表示BMP范围内的Unicode字符。BMP表示[U+0000, U+FFFF]之间的Unicode字符。而且，绝大部分的中文字符的Unicode范围是[0x4E00, 0x9FBB],恰好是在BMP范围内。</p>\n<p>就常用的UTF-8编码来说，我们都听说过他是用3或者4个字节来表示一个汉字的。就拿3个字节来算的话，一个char也存不下？？</p>\n<p>UTF-8编码和代码点对应关系:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Unicode编码</th>\n<th align=\"center\">UTF-8字节流</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">000000 - 00007F</td>\n<td align=\"center\">0xxxxxxx</td>\n</tr>\n<tr>\n<td align=\"center\">000080 - 0007FF</td>\n<td align=\"center\">110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td align=\"center\">000800 - 00FFFF</td>\n<td align=\"center\">1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td align=\"center\">010000 - 10FFFF</td>\n<td align=\"center\">11110xxx 10xxxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<p>当一个字节表示一个字符时，二进制开头是0；当两个字节表示一个字符时，二进制开头是11；当3个字节表示一个字符时，二进制开头是111。UTF-8编码加入了多余的标识位来区分一个Unicode代码点！才会出现中文汉字集中在[0x4E00, 0x9FBB]范围的16bit数值内，UTF-8却需要3个字节存储的原因。</p>\n<p>那么UTF-8占用3到4个字节，char只能存2个字节（16bit），然而UTF-8中的几乎所有汉字都是在BMP范围内，也就是在char可存储的范围内，是不是矛盾了？</p>\n<p>其实不然，</p>\n<ol>\n<li><p>char字符存储的是Unicode编码的代码点，也就是存储的是U+FF00这样的数值，然而我们在调试或者输出到输出流的时候，是JVM或者开发工具按照代码点对应的编码字符输出的，Java内部使用UTF-16编码。</p>\n</li>\n<li><p>所以虽然UTF-8编码的中文字符是占用3个或者4个字节，但是对应的代码点仍然集中在[0x4E00, 0x9FBB]，所以char是能够存下在这个范围内的中文字符的。</p>\n</li>\n<li><p>但是对于超过16bit的Unicode字符集，也就是Unicode的扩展字符集，一个char是放不下的，需要两个char才能放下。</p>\n</li>\n</ol>\n<p>另外，如何判断java字符串是否包含中文？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 判断某个字符是否为汉字</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> c 需要判断的字符</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 是汉字返回true，否则返回false</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isChinese</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    String regex = <span class=\"string\">&quot;[\\\\u4e00-\\\\u9fa5]&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> String.valueOf(c).matches(regex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里没有考虑CJK扩展字符集。</p>\n<p>PS: 一个查找中文字符utf-8编码网址：<a href=\"http://www.mytju.com/classcode/tools/encode_utf8.asp\">http://www.mytju.com/classcode/tools/encode_utf8.asp</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"https://www.cnblogs.com/softidea/p/10271219.html\">Java中的char究竟能存中文吗？</a></p>\n<p><a href=\"https://blog.csdn.net/buqutianya/article/details/80685437\">细说Java中的字符和字符串（一）</a></p>\n<p><a href=\"https://github.com/hankcs/HanLP/blob/master/src/main/java/com/hankcs/hanlp/utility/TextUtility.java\">HanLP自然语言处理库</a></p>\n","tags":["Java"]},{"title":"Java泛型","url":"/2020/03/05/java_generics/","content":"<h3 id=\"Java泛型-类型擦除\"><a href=\"#Java泛型-类型擦除\" class=\"headerlink\" title=\"Java泛型 类型擦除\"></a>Java泛型 类型擦除</h3><p>正确理解泛型概念的首要前提是理解类型擦除(type erasure)。Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成List。JVM看到的只是<code>List</code>，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</p>\n<h3 id=\"Java泛型特性\"><a href=\"#Java泛型特性\" class=\"headerlink\" title=\"Java泛型特性\"></a>Java泛型特性</h3><ul>\n<li><p>泛型类并没有自己独有的Class类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</p>\n</li>\n<li><p>静态变量是被泛型类的所有实例所共享的。对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是 <code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量。</p>\n</li>\n<li><p>泛型的类型参数不能用在Java异常处理的<code>catch</code>语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于JVM来说，它们都是<code> MyException</code>类型的。也就无法执行与异常对应的<code>catch</code>语句。</p>\n<h4 id=\"不允许创建参数化类型数组\"><a href=\"#不允许创建参数化类型数组\" class=\"headerlink\" title=\"不允许创建参数化类型数组\"></a>不允许创建参数化类型数组</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pair&lt;String&gt;[] table = <span class=\"keyword\">new</span> Pair&lt;String&gt;[<span class=\"number\">10</span>];  <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<p>擦除之后，<code>table</code>的类型是<code>Pair[]</code>。可以把它转换为<code>Object[]</code>:<code>Object[] objarray = table;</code></p>\n<p>数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个<code>ArrayStoreException</code>异常：<code>objarray[0] = &quot;hello&quot;; // Error--component tye is Pair</code></p>\n<p>不过对于泛型类型， 擦除会使这种机制无效。</p>\n<p><code>objarray[0] = new Pair&lt;Employee&gt;()</code>能够通过数组存储检查，不过仍会导致一个类型错误。</p>\n<p>处于安全考虑呢，Java不允许创建参数化类型的数组。</p>\n</li>\n</ul>\n<h3 id=\"Java泛型与C-模板-差异之处\"><a href=\"#Java泛型与C-模板-差异之处\" class=\"headerlink\" title=\"Java泛型与C++模板 差异之处\"></a>Java泛型与C++模板 差异之处</h3><p>“泛型编程”这个概念最早就是来源于C++当初设计STL时所引入的模板（Template），而为什么要引入模板呢，因为STL要完成这样一个目标：设计一套通用的，不依赖类型的，高效的的算法（例如<code>std::sort</code>）和数据结构（例如<code>std::list</code>）。关于通用性，运行时多态（Polymorphism）可以做到（例如很多高级语言的继承（Inheritance）机制，接口（Interface）机制），但是C++作为一门相对底层的语言，对运行效率的要求是很严格的，而运行时多态会影响效率（例如成员函数只有在运行时才知道调用哪个），所以设计STL的人就创造了一种编译时多态技术，即模板。</p>\n<p>那什么又是编译时多态呢，简单点说就是让编译器帮我确定类型，我写程序时只要标记下这里我要用“某种类型”的对象，至于具体是什么类型我不关心，你编译器帮我确定，编译完成后在运行时绝对是类型确定的，这样就大大提高了运行效率，反之对编译就增加了很多工作，而且生成的目标代码也会大大增加。所以对C++来说，所谓“泛型（Generics）”，并不是说编译器不知道类型，而是针对程序员来说的，这也正是通用性的体现。</p>\n<p>在 C++ 模板中，编译器使用提供的类型参数来扩充模板，因此，为 <code>List&lt;A&gt;</code> 生成的 C++ 代码不同于为 <code>List&lt;B&gt;</code> 生成的代码，<code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code> 实际上是两个不同的类。而 Java 中的泛型则以不同的方式实现，编译器仅仅对这些类型参数进行擦除和替换。类型 <code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 的对象共享相同的类，并且只存在一个 <code>ArrayList</code> 类</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References:\"></a>References:</h2><ol>\n<li>Java核心技术</li>\n<li><a href=\"https://codefine.site/1759.html\">Java泛型：类型檫除、模板和泛型传递</a></li>\n</ol>\n","tags":["Java","Java Generics"]},{"title":"Java IO","url":"/2020/04/01/java_io/","content":"<h1 id=\"Java-I-O\"><a href=\"#Java-I-O\" class=\"headerlink\" title=\"Java I/O\"></a>Java I/O</h1><p>I/O流 概念： 流数据从一端传到另一端</p>\n<p>Java I/O流分为三大类：</p>\n<ul>\n<li>按照读写单元（bit or byte）：字节流，字符流</li>\n<li>按照流的方向：输入流，输出流</li>\n<li>按照功能分：节点流，处理流</li>\n</ul>\n<p>字节流和字符流：</p>\n<ul>\n<li>当我们读取文件然后再写入其他文件时，不用过多的关注读取的内容时，通常使用的是字节流，因为这相当于是在处理二进制文件。读取数据效率高，并且保持数据的完整性；当我们读取文件的内容，并对文件的内容进行加工时，通常使用字符流。</li>\n</ul>\n<p>节点流和处理流：</p>\n<ul>\n<li>节点流：即从特定的数据源读取写入数据</li>\n<li>处理流：在已经存在的节点流或者处理流上，进行装饰提供更强大的读写功能<ol>\n<li>缓冲流（Buffered）带缓冲区，在节点流上添加缓冲区（例如：<code>new BufferedInputStream(new FileInputStream())</code>），这样避免读取文件时，大量进行硬盘的读写，提高读写效率</li>\n<li>转换流（StreamReader）即字节流和字符流的相互转换，比如：在进行读写字节流时，想调用读取字符流的函数，就可以通过转换流。<code>InputStreamReader in = new InputStreamReader(new InputStream())</code> <strong>注意只能字节流=&gt;字符流</strong></li>\n<li>数据流（Data）当读取写入具体的数值数据时，<code>DataInputStream</code>可以让你从<code>InputStream</code>读取Java基本类型来代替原始字节。如果读取的数据是由大于一个字节的Java基本类型构成，如int，long，float，double等，那么用<code>DataInputStream</code>是很方便的。读取的时候记住先读先写的原则，顺序不能乱，因为Java基本类型都是大于一个字节的，顺序不对，读取出来会出现乱码。所以在用<code>DataInputStream</code>的时候要么为文件中的数据采用固定格式，要么将额外信息保存到文件中，以便解析的时候确定数据位置和类型使用。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"Java-IO类结构\"><a href=\"#Java-IO类结构\" class=\"headerlink\" title=\"Java IO类结构\"></a>Java IO类结构</h3><p><strong><code>InputStream, OutputSteam, Reader, Writer</code>都是抽象类</strong></p>\n<p>贴张图：</p>\n<p><img src=\"/../images/java_IO.jpeg\"></p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://blog.csdn.net/qq_16558621/article/details/51377887\">Java流机制详解</a><br><a href=\"https://blog.csdn.net/zhaoyanjun6/article/details/54292148\">Java IO流学习总结一：输入输出流</a></p>\n","tags":["Java"]},{"title":"Josephus Problem","url":"/2020/07/15/josephus-problem/","content":"<h1 id=\"Josephus-Problem\"><a href=\"#Josephus-Problem\" class=\"headerlink\" title=\"Josephus Problem\"></a>Josephus Problem</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>Josephus problem (or Josephus permutation), 简单说，N个人围成一圈，从某一人（比如第k个）开始报数，报到m的人退出，如此循环，直到最后一个人</p>\n<blockquote>\n<p>People are standing in a circle waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed.</p>\n</blockquote>\n<h2 id=\"解法1-circular-linked-list\"><a href=\"#解法1-circular-linked-list\" class=\"headerlink\" title=\"解法1: circular linked list\"></a>解法1: circular linked list</h2><p>循环链表解法很直接，复杂度O(n)</p>\n<p>每个Node就是问题中的一个人，数到谁就删除相应的Node，最后只剩一个Node</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">createCirLinkedList</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">     Node head = <span class=\"keyword\">new</span> Node(<span class=\"number\">1</span>);</span><br><span class=\"line\">     Node next = head;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= N; i++)&#123;</span><br><span class=\"line\">         Node tmp = <span class=\"keyword\">new</span> Node(i);</span><br><span class=\"line\">         next.next = tmp;</span><br><span class=\"line\">         next = next.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      next.next = head;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> N, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">/* create circurlar linked list */</span></span><br><span class=\"line\">     Node head = createCirLinkedList(N);</span><br><span class=\"line\">     <span class=\"comment\">/* remove node recursively */</span> </span><br><span class=\"line\">     <span class=\"keyword\">while</span> (head != head.next)&#123;</span><br><span class=\"line\">         <span class=\"comment\">/* move head point to the previous node before to-be-deleted node */</span></span><br><span class=\"line\">         <span class=\"comment\">/* head.next is the node to be deleted */</span></span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">             head = head.next;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.print(head.next.data+<span class=\"string\">&quot;-&gt;&quot;</span>);</span><br><span class=\"line\">         <span class=\"comment\">/* remove the m-th node */</span></span><br><span class=\"line\">         head.next = head.next.next;</span><br><span class=\"line\">         head = head.next;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.print(<span class=\"string\">&quot;Done!\\n&quot;</span>);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> head.data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解法2-数学方法递推公式\"><a href=\"#解法2-数学方法递推公式\" class=\"headerlink\" title=\"解法2: 数学方法递推公式\"></a>解法2: 数学方法递推公式</h2><p>求Josephus的递推就比较有意思啦，正向不行，得反着来。所有人围成一个圆，整个序列从任意一点开始都可，0点（index是0）是谁都一样可以数下去。那么每轮都把上一次被删除的那个人的下一个位置作为新的0点，开始新一轮数数。这样子，每一轮都是重复一样的模式在数数，recursion来了。</p>\n<p>$J(n)$表示n个人玩最后胜利者的编号（编号从0开始），按照这样设定初始条件$J(1) = 0$  </p>\n<p>过程：</p>\n<p>$J(n)$:</p>\n<p>   编号m % ( n - 1 )出局，剩下的人组成一个新的环，从k = m % n开始</p>\n<p>   0, 1, 2, 3, 4, …, k-2, <del>k-1,</del> k, k+1, k+2, k+3, k+4, …, n-1</p>\n<p>$J(n-1)$:</p>\n<p>   n-k, n-k+1, n-k+2,…, n-2,   0, 1, 2, 3, 4, …, n-k-1,</p>\n<p>   编号做一下转换：</p>\n<pre><code>        J(n)编号 --&gt; J(n-1)编号\n\n               k --&gt; 0\n\n             k+1 --&gt; 1\n\n             k+2 --&gt; 2\n\n                 ...\n\n             k-2 --&gt; n-2\n\n             k-1 --&gt; n-1\n</code></pre>\n<p>n个人玩J(n)时的序号转换成n-1个人玩J(n-1)的序号，这样之，当我们知道子问题J(n-1）的胜利者编号就可以转换成J(n)时的编号，J(1)-&gt;J(2)-&gt;…-&gt;J(n-1)-&gt;J(n), 递推公式就来了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">   J(n) &#x3D; (J(n-1) + k) % n, k &#x3D; m % n</span><br><span class=\"line\">&#x3D;&gt; J(n) &#x3D; (J(n-1) + m % n) % n</span><br><span class=\"line\">        &#x3D; (J(n-1) + m) % n</span><br></pre></td></tr></table></figure>\n\n<p>递推公式:<br>J(1) = 0<br>J(n) = (J(n-1) + m) % n</p>\n<h3 id=\"recursive\"><a href=\"#recursive\" class=\"headerlink\" title=\"recursive\"></a>recursive</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> N, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">/* index begin at 0 */</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (N == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (recursiveSolve(N - <span class=\"number\">1</span>, m) + m) % N;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* when index begins at 1 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> res = solve(N, m) + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"iterative\"><a href=\"#iterative\" class=\"headerlink\" title=\"iterative\"></a>iterative</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> N, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">/* index begin at 0 */</span></span><br><span class=\"line\">     <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= N; i++)&#123;</span><br><span class=\"line\">         res = (res + m) % i;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">/* when index begin at 1 */</span></span><br><span class=\"line\">     res = res + <span class=\"number\">1</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://en.wikipedia.org/wiki/Josephus_problem\">Josephus problem wikipedia</a></p>\n<p><a href=\"https://www.cnblogs.com/jclian91/p/8660123.html\">Josephus Problem的详细算法</a></p>\n","tags":["algorithms"]},{"title":"Linux内核空间","url":"/2019/12/24/linux_kernel_space/","content":"<h1 id=\"Linux内核空间，用户空间\"><a href=\"#Linux内核空间，用户空间\" class=\"headerlink\" title=\"Linux内核空间，用户空间\"></a>Linux内核空间，用户空间</h1><p>用户界面是操作系统的外在表象，内核才是操作系统的内在核心。系统其他部分必须依靠内核这部分软件提供的服务，像管理硬件设备、分配系统资源等。内核有时候被称作是管理者或者是操作系统核心。通常一个内核由负责响应中断的中断服务程序、负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。对于提供保护机制的现代系统来说，内核独立于普通应用程序，他一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和被保护起来的内存空间，统称为内核空间。相对的，应用程序在用户空间执行。它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划给别人的内存范围，还有其他一些使用限制。当内核运行的时候，系统以内核态进入内核空间执行。而执行一个普通用户程序时，系统将以用户态进入用户空间执行。</p>\n<ol>\n<li><p>用户空间、内核空间</p>\n<p>现代操作系统都是采用虚拟存储器，对于32位操作系统，它的逻辑内存（虚拟存储空间）为4G（2^32）。为了保护内核，将其与用户应用程序代码隔离开来，操作系统将逻辑内存划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用；将较低的3G字节（从0x00000000到0xBFFFFFFF）供用户进程使用。每个进程可以通过系统调用进入内核。</p>\n<p><img src=\"/../images/linux%E7%B3%BB%E7%BB%9F4G%E9%80%BB%E8%BE%91%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D.png\" alt=\"linux系统4G逻辑内存空间分配\"></p>\n<p>内核空间存放linux内核代码和数据，用户空间存放的是用户的程序代码和数据。Linux只使用Intel的Ring0和Ring3两级保护机制（Ring0供内核使用，Ring3供用户空间使用）</p>\n<p><img src=\"/../images/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png\" alt=\"linux操作系统内部结构\"></p>\n<p><strong>但一个进程执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）</strong>。此时内核正在代其执行，在这种情况下，进程被称为通过系统调用在内核空间运行，而内核被称为运行于进程上下文中。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>\n<p><strong>当进程在执行用户程序代码时，则称其处于用户运行态（用户态）</strong>。</p>\n</li>\n<li><p>进程上下文，中断上下文<br>上下文（context）简单来说就是一个环境。对于进程来说就是进程执行时的环境。<br>用户空间的程序通过系统调用进入内核空间。这个时候用户空间的进程要传递很多变量、参数给内核，内核态运行的时候也要保存用户进程的一些寄存器的值、变量等。相对于进程而言，具体就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分：用户级上下文、寄存器上下文以及系统上下文。</p>\n<ul>\n<li>用户级上下文：正文、数据、用户堆栈以及共享存储器；</li>\n<li>寄存器上下文：通用寄存器、程序寄存器、处理器状态寄存器、栈指针；</li>\n<li>系统级上下文：进程控制块（task_struct)、内存管理信息（mm_struct, vm_area_struct, pgd, pte）、内核栈<br>当发生进程调度时，进行进程切换就是上下文切换（context switch）。操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换（mode switch），模式切换相较于进程切换，容易很多，而且节省时间，因为模式切换最主要的任务时切换进程寄存器。</li>\n</ul>\n<p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通多这些参数进行中断处理。所谓中断上下文，其实也可以看作硬件传递过来的参数和内核需要保存的一些环境。中断时，内核不代替任何进程运行，而是执行中断处理，与之没有进程相关联，也就没有进程上下文。内核运行与中断上下文时，不会被阻塞，因为此时没有与之关联的进程上下文，也就没有进程。</p>\n</li>\n</ol>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References:\"></a>References:</h1><p>Linux内核设计与实现（第三版）<br><a href=\"https://www.cnblogs.com/Anker/p/3269106.html\">用户空间与内核空间，进程上下文与中断上下文</a></p>\n","tags":["Linux","操作系统","OS"]},{"title":"Linux系统结构","url":"/2019/11/10/linux_structure/","content":"<h1 id=\"Linux系统结构\"><a href=\"#Linux系统结构\" class=\"headerlink\" title=\"Linux系统结构\"></a>Linux系统结构</h1><p>Linux系统有4个主要部分：内核，shell，文件系统和应用程序。内核，shell和文件系统一起形成了基本的操作系统，它们使用户可以运行程序、管理文件并使用系统。</p>\n<p><img src=\"/../images/linux_structure.png\" alt=\"linux structure\"></p>\n<hr>\n<ol>\n<li><p>Linux内核</p>\n<p>内核是操作系统的核心，负责管理系统的进程、内存、设备驱动程序、文件和网络系统。</p>\n<p><img src=\"/../images/linux_kernel.jpg\" alt=\"linux_kernel\"></p>\n<p>**系统调用接口: **SCI层提供了某些机制执行从用户空间到内核的函数调用。SCI实际上是一个非常有用的函数调用多路复用和多路分解服务。</p>\n<ul>\n<li><p>内存管理</p>\n<p>Linux采用了虚拟内存的内存管理方式。Linux将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是4KB）。Linux包括了管理内存的方式，以及物理和虚拟映射所使用的硬件机制。</p>\n<p>不过内存管理要管理的可不止4KB缓冲区。Linux提供了对4KB缓冲区的抽象。这种内存管理模式使用4KB缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。</p>\n<p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。因此，页面可以一处内存并放入磁盘中。这个过程称为交换，因为页面会从内存交换到硬盘上。</p>\n</li>\n<li><p>进程管理</p>\n<p>进程实际是某个特定应用程序的一个运行实体。在Linux系统中，能够同时运行多个进程，Linux通过在短时间间隔内轮流运行这些进程而实现“多任务”。这一短时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度”。</p>\n<p>进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其他资源，着该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。</p>\n<p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且</p>\n</li>\n<li><p>文件系统</p>\n</li>\n<li><p>设备驱动程序</p>\n</li>\n<li><p>网络接口（NET）</p>\n</li>\n</ul>\n<hr>\n</li>\n<li><p>Linux Shell</p>\n<p>…</p>\n<hr>\n</li>\n<li><p>Linux文件系统</p>\n<p>…</p>\n<hr>\n</li>\n<li><p>应用程序</p>\n<p>Linux系统一般都有一套称为应用程序的程序集，包括文本编辑器、编程语言、x window、Internet工具和数据库等。</p>\n<hr>\n</li>\n<li><p>内核参数</p>\n<p>Linux内核提供了一种通过/proc文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p>\n<p>用户和应用程序可以通过/proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取/proc文件时，/proc文件系统是动态从系统内核读出所需信息并提交的。在/proc下有三个很重要的目录：/net，/scsi和/sys。/sys目录是可写的，可一通过它来访问或修改内核的参数，而/net和/scsi则依赖于内核配置。例如，如果系统不支持scsi，则scsi目录不存在。</p>\n<p>除了这些，还有一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在/proc下，以进程的PID为目录名，它们是读取进程信息的接口。而/self目录则是读取进程本身的信息接口，是一个link，不同进程访问该目录是获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self来获取自己的系统信息，而不用每次都获取pid。</p>\n</li>\n</ol>\n<p>Reference:</p>\n<p>[1] <a href=\"https://blog.csdn.net/hguisu/article/details/6122513#t7\">Linux系统结构 详解</a></p>\n<p>[2] <a href=\"https://blog.csdn.net/zdwzzu2006/article/details/7747977\">Linux下/proc目录简介</a></p>\n","tags":["Linux","操作系统","OS"]},{"title":"二进制数中1的个数","url":"/2021/04/09/population-count/","content":"<h1 id=\"二进制数中1的个数\"><a href=\"#二进制数中1的个数\" class=\"headerlink\" title=\"二进制数中1的个数\"></a>二进制数中1的个数</h1><ol>\n<li><p>naive，一位一位数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">popcount</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n += x &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">        x = x &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>相对暴力，只数有1的位，复杂度O(有多少个1)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">popcount</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x) &#123;</span><br><span class=\"line\">        x = x &amp; (x - <span class=\"number\">1</span>);</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>二分法, 复杂度O(log32)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">popcount</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * swar algorithm, work on 32 bit integer</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       n = (n &amp; <span class=\"number\">0x55555555</span>) + ((n &gt;&gt; <span class=\"number\">1</span>) &amp; <span class=\"number\">0x55555555</span>);</span><br><span class=\"line\">       n = (n &amp; <span class=\"number\">0x33333333</span>) + ((n &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">0x33333333</span>);</span><br><span class=\"line\">       n = (n &amp; <span class=\"number\">0x0F0F0F0F</span>) + ((n &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0x0F0F0F0F</span>);</span><br><span class=\"line\">       n = (n &amp; <span class=\"number\">0x00FF00FF</span>) + ((n &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0x00FF00FF</span>);</span><br><span class=\"line\">       n = (n &amp; <span class=\"number\">0x0000FFFF</span>) + ((n &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0x0000FFFF</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>想法类似二分，两两相加</p>\n<p><img src=\"/2021/04/09/population-count/%E4%BA%8C%E5%88%86%E6%B3%95%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B.jpg\" alt=\"二分法简单示例\"></p>\n<p>将32位数看成相互独立的32个 0-1 数字,<br>然后两两相加, 这样我们就有16个数字了,<br>然后再两两相加, 就变成8个数字了,<br>接着再两两相加变成4个,<br>然后两个, 最后一个数字,<br>由于是32位数字的和, 所以答案刚好就是1的个数啦。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">右移 1位. 与数字: 01010101010101010101010101010101 &#x3D;&gt; 0x55555555</span><br><span class=\"line\">右移 2位. 与数字: 00110011001100110011001100110011 &#x3D;&gt; 0x33333333</span><br><span class=\"line\">右移 4位. 与数字: 00001111000011110000111100001111 &#x3D;&gt; 0x0F0F0F0F</span><br><span class=\"line\">右移 8位. 与数字: 00000000111111110000000011111111 &#x3D;&gt; 0x00FF00FF</span><br><span class=\"line\">右移16位. 与数字: 00000000000000001111111111111111 &#x3D;&gt; 0x0000FFFF</span><br></pre></td></tr></table></figure></li>\n<li><p>查表，预先算好，查询时直接读</p>\n<p>表的大小可以改，比如256，适当取</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1&lt;&lt;16</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> table[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class=\"line\">        table[i] = table[i &gt;&gt; <span class=\"number\">1</span>] + (i &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">popcount</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (table[x &gt;&gt; <span class=\"number\">16</span>] + table[x &amp; <span class=\"number\">0xFFFF</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"http://github.tiankonguse.com/blog/2014/11/16/bit-count-more.html\">详解二进制数中1的个数</a></p>\n","tags":["algorithms"]},{"title":"Install PostgreSQL 12","url":"/2020/11/20/postgresql-install/","content":"<h1 id=\"PostgreSQL-12-Installation\"><a href=\"#PostgreSQL-12-Installation\" class=\"headerlink\" title=\"PostgreSQL 12 Installation\"></a>PostgreSQL 12 Installation</h1><ol>\n<li><p>add postgresql-12 repository</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;deb http://apt.postgresql.org/pub/repos/apt/ `lsb_release -cs`-pgdg main&quot;</span> |sudo tee /etc/apt/sources.list.d/pgdg.list</span><br><span class=\"line\">$ sudo apt update</span><br></pre></td></tr></table></figure>\n\n<p>the repository contains packages including: </p>\n<ul>\n<li>postgresql-client</li>\n<li>postgresql</li>\n<li>libpq-dev</li>\n<li>postgresql-server-dev</li>\n<li>pgadmin packages</li>\n</ul>\n</li>\n<li><p>install postgresql server and client</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt -y install postgresql-12 postgresql-client-12</span><br></pre></td></tr></table></figure></li>\n<li><p>postgresql first-time login</p>\n<p>Switch to user postgres to login database postgres. Postgresql has by default 3 databases “postgres, template 0, template 1”.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo -u postgres psql postgres</span><br></pre></td></tr></table></figure>\n\n<p>create a test database and a test user</p>\n<p>(CREATE USER = CREATE ROLE + LOGIN permission)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">   postgres&#x3D;# CREATE DATABASE mytestdb;</span><br><span class=\"line\">   CREATE DATABASE</span><br><span class=\"line\">   postgres&#x3D;# CREATE USER mytestuser WITH ENCRYPTED PASSWORD &#39;MyStr0ngP@ss&#39;;</span><br><span class=\"line\">CREATE ROLE</span><br><span class=\"line\">   postgres&#x3D;# GRANT ALL PRIVILEGES ON DATABASE mytestdb TO mytestuser;</span><br><span class=\"line\">GRANT</span><br></pre></td></tr></table></figure>\n\n<p>now list all databases</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">postgres&#x3D;# \\l</span><br></pre></td></tr></table></figure>\n\n<p>connect to newly-created database</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">postgres&#x3D;# \\c mytestdb</span><br></pre></td></tr></table></figure></li>\n<li><p>“Peer authentication failed for user XXX”</p>\n<p>edit in file <code>/etc/postgresql/12/main/pg_hba.conf</code>, replace <code>peer</code> with <code>md5</code></p>\n<ul>\n<li><code>peer</code> means it will trust the authenticity of UNIX user hence does not prompt for the password.</li>\n<li><code>md5</code> means it will always ask for a password, and validate it after hashing with <code>MD5</code></li>\n</ul>\n<p>from</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class=\"line\"></span><br><span class=\"line\"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class=\"line\">local   all             all                                     peer</span><br><span class=\"line\"># IPv4 local connections:</span><br><span class=\"line\">host    all             all             127.0.0.1&#x2F;32            md5</span><br></pre></td></tr></table></figure>\n\n<p>to</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class=\"line\"></span><br><span class=\"line\"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class=\"line\">local   all             all                                     md5</span><br><span class=\"line\"># IPv4 local connections:</span><br><span class=\"line\">host    all             all             127.0.0.1&#x2F;32            md5</span><br></pre></td></tr></table></figure>\n\n<p>then restart postgresql</p>\n<p><code>sudo systemctl restart postgresql.service</code></p>\n</li>\n</ol>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://computingforgeeks.com/install-postgresql-12-on-ubuntu/\">How To Install PostgreSQL 12 on Ubuntu 20.04/18.04/16.04</a></p>\n","tags":["postgresql"]},{"title":"蓄水池抽样","url":"/2021/04/24/reservoir-sampling/","content":"<h1 id=\"蓄水池抽样\"><a href=\"#蓄水池抽样\" class=\"headerlink\" title=\"蓄水池抽样\"></a>蓄水池抽样</h1><p><strong>给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出k个不重复的数据。</strong></p>\n<p>算法应用的场景特点：</p>\n<ol>\n<li>online算法，数据流一遍输入一遍抽样</li>\n<li>时间复杂度O(N)</li>\n<li>每个样本抽中概率=<strong>k/N</strong>，（k是事先确定的，与N无关）$^1$</li>\n</ol>\n<h3 id=\"抽样过程\"><a href=\"#抽样过程\" class=\"headerlink\" title=\"抽样过程:\"></a>抽样过程:</h3><ul>\n<li><p>假设数据序列的规模为 n，需要采样的数量的为 k。</p>\n</li>\n<li><p>首先构建一个可容纳 k 个元素的数组，将序列的前 k 个元素放入数组中。</p>\n</li>\n<li><p>然后从第 i = k+1 个元素开始，生成一个随机数 d∈[1,i]， 如果 d &lt;= k， 那么蓄水池的第 d 个元素被替换为数据流中的第 i 个元素</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] reservoir;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sample</span><span class=\"params\">(<span class=\"keyword\">int</span>[] dataStream)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; reservoir.length; i++) &#123;</span><br><span class=\"line\">        reservoir[i] = dataStream[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = k; i &lt; dataStream.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = rand.nextInt(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d &lt; k) &#123;</span><br><span class=\"line\">            reservoir[d] = dataStream[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"算法正确性：\"><a href=\"#算法正确性：\" class=\"headerlink\" title=\"算法正确性：\"></a>算法正确性：</h3><ol>\n<li><p>对于第 i 个数（i ≤ k）。在 k 步之前，被选中的概率为 1。当走到第 k+1 步时，被 k+1 个元素替换的概率 = k+1 个元素被选中的概率 x i 被选中替换的概率，即为 $\\frac{k}{k+1}\\frac{1}{k}=\\frac{1}{k+1}$。则被保留的概率为 $1-\\frac{1}{k+1}=\\frac{k}{k+1}$。依次类推，不被 k+2 个元素替换的概率为 $1-\\frac{k}{k+2}\\frac{1}{k}=\\frac{k+1}{k+2}$。则运行到第 n 步时，被保留的概率 = 被选中的概率 x 不被替换的概率，即：<br>$$1\\frac{k}{k+1}\\frac{k+1}{k+2}\\frac{k+2}{k+3}…\\frac{N-1}{N} = \\frac{k}{N}$$</p>\n</li>\n<li><p>对于第 j 个数（j &gt; k）。在第 j 步被选中的概率为 $\\frac{k}{j}$。不被 j+1 个元素替换的概率为 $1 - \\frac{k}{j+1}\\frac{1}{k} = \\frac{j}{j+1}$。则运行到第 n 步时，被保留的概率 = 被选中的概率 x 不被替换的概率，即：<br>$$\\frac{k}{j}\\frac{j}{j+1}\\frac{j+1}{j+2}\\frac{j+2}{j+3}…\\frac{N-1}{N} = \\frac{k}{N}$$</p>\n</li>\n</ol>\n<p>所以对于其中每个元素，被保留的概率都为 $\\frac{k}{N}$.</p>\n<h3 id=\"题外\"><a href=\"#题外\" class=\"headerlink\" title=\"题外\"></a>题外</h3><p>抽样证明过程看起来和Knuth-shuffle算法有点像</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(T[] A)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = A.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rand = (<span class=\"keyword\">int</span>) (Math.random() * (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"comment\">// swap A[i] and A[rand]</span></span><br><span class=\"line\">        T temp = A[i];</span><br><span class=\"line\">        A[i] = A[rand];</span><br><span class=\"line\">        A[rand] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"https://www.jianshu.com/p/7a9ea6ece2af\">蓄水池抽样算法（Reservoir Sampling）</a></p>\n<p><a href=\"https://www.cnblogs.com/python27/p/Reservoir_Sampling_Algorithm.html\">【算法34】蓄水池抽样算法 (Reservoir Sampling Algorithm)</a></p>\n<p><a href=\"https://www.cnblogs.com/snowInPluto/p/5996269.html\">蓄水池采样算法</a></p>\n<p>$^1$ 如果k与N有关呢？ 例如k=N/3，怎么抽样，思考一下</p>\n","tags":["Algorithms"]},{"title":"Socket编程","url":"/2019/08/16/socket_programming/","content":"<h1 id=\"Socket编程\"><a href=\"#Socket编程\" class=\"headerlink\" title=\"Socket编程\"></a>Socket编程</h1><ol>\n<li>网络中进程间通信</li>\n</ol>\n<p>进程通信的概念最初来自于单机系统。网络间进程通信要解决的是不同主机进程间的相互通信问题（可把统计进程通信看做是其中的特列）。首先需要解决的是网络间进程标识的问题。同一主机上，不同进程可以用进程号（PID）来区分。但在局域网中，各主机独立分配进程号，不同主机不同基层可能拥有相同的进程号，所以无法用来唯一标识。</p>\n<p>TCP/IP协议族可以解决这个问题，网络层的”ip地址“可以唯一标识网络中的主机，而传输层的”协议+端口号“可以唯一标识主机中的进程。这样一个三元组（IP地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标识与其他进程交互。</p>\n<p>使用TCP/IP协议的程序通常采用应用编程接口：UNIX BSD的套接字（socket）来实现网络进程之间的通信。</p>\n<ol start=\"2\">\n<li>socket套接字</li>\n</ol>\n<p>socket起源于Unix，而Unix基本哲学之一就是”一切皆文件“， 都可以用”open -&gt; write/read -&gt; close“模式来操作。socket就是该模式的一个实现。socket即是一种特殊的文件，一些socket函数就是对其进行的操作。</p>\n<p>socket是在应用层与TCP/IP之间的一个软件抽象层次，准确的说，它是一个接口。在设计模式中，socket使用了门面模式（Facade pattern）。它将复杂的TCP/IP协议族隐藏在socket接口后面，对用户来说，一组简单的接口就是全部，让socket去组织数据。</p>\n<p><img src=\"/../images/socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png\" alt=\"socket通信\"></p>\n<ol start=\"3\">\n<li>客户端/服务器socket通信简单例子</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 客户端</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># create socket descriptor</span></span><br><span class=\"line\">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\"><span class=\"comment\"># connect with local loopback address</span></span><br><span class=\"line\">client.connect((<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># receive message from server, and send message from console input</span></span><br><span class=\"line\"><span class=\"comment\"># close the socket until input &#x27;exit&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    data = client.recv(<span class=\"number\">1024</span>)</span><br><span class=\"line\">    print(data.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    msg = input(<span class=\"string\">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class=\"line\">    client.send(msg.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> msg == <span class=\"string\">&#x27;exit&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">client.close()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 服务器端</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">s.bind((<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>))</span><br><span class=\"line\">s.listen(<span class=\"number\">5</span>)  <span class=\"comment\"># backlog number</span></span><br><span class=\"line\">print(<span class=\"string\">&#x27;Waiting for connection...&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># accept connection from client</span></span><br><span class=\"line\"><span class=\"comment\"># receive message from client and send a random integer back </span></span><br><span class=\"line\"><span class=\"comment\"># until receive &#x27;exit&#x27;, close the connection and wait for next one</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    conn, addr = s.accept()</span><br><span class=\"line\">    conn.send(<span class=\"string\">b&#x27;Welcome&#x27;</span>)</span><br><span class=\"line\">    print(<span class=\"string\">&#x27;Connected with %s:%s&#x27;</span> % addr)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        data = conn.recv(<span class=\"number\">1024</span>)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)  <span class=\"comment\"># simple way to unpack block</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> data <span class=\"keyword\">or</span> data.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>) == <span class=\"string\">&#x27;exit&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            msg = random.randint(<span class=\"number\">1</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">            conn.send(str(msg).encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">    conn.close()</span><br><span class=\"line\">    print(<span class=\"string\">&#x27;Connection from %s:%s closed\\n&#x27;</span> % addr)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>Python socket编程</p>\n<p>a. 创建socket描述符</p>\n<p><code>socket.socket(address_family, socket_type, protocol)</code></p>\n<p><code>address_family</code>选择协议族（都以AF_开头），决定地址格式。<code>socket_type</code>确定套接字的类型。<code>protocol</code>指定协议。</p>\n<p>b. 链接<code>connect()</code></p>\n<p>c. 监听<code>bind()</code></p>\n<p><code>accept()</code></p>\n<p>d. 接受<code>recv()</code> <code>recvfrom()</code> </p>\n<p>e. 发送 <code>send()</code>  <code>sendto()</code></p>\n</li>\n<li><p>Unix/linux下网络处理多连接</p>\n<p>解决多客户‘并发’的方式：</p>\n<p>a. 多线程</p>\n<p>每当有客户端连接，启动一个线程来处理客户端数据</p>\n<p>b. 异步I/O</p>\n<p><code>asyncio</code>库使用单线程来处理多任务, 使用事件循环来管理任务</p>\n<p>c. I/O复用，同步非阻塞监听</p>\n</li>\n</ol>\n<p>先来理解下复用这个概念，复用也就是共用的意思。比较形象的解释，先看在通信领域中的使用，在通信领域中为了充分利用网络连接的物理介质，往往在同一条网络链路上采用时分复用或者频分复用的技术使其在同一链路上传输多路信号。对于网络编程来说，客户端发来的请求服务端会产生一个进程来对其服务，每当来一个客户请求就产生一个进程来服务，然而进程不可能无限制的产生，因此为了解决大量客户端访问的问题，引入了I/O复用技术：一个进程可以同时对多个客户请求进行服务。也就是说I/O复用的介质是进程，复用一个进程来对多个I/O进行服务，虽然客户端发来的I/O是并发的，但是I/O所需的读写数据多数情况下是没有准备好的，因此就可以利用<code>select</code>或者<code>poll</code> 来监听I/O所需的这些数据的状态，一旦I/O有数据可以进行读写了，进程就来对这样的I/O进行服务。</p>\n<blockquote>\n<p>To support the implementation of servers, the socket interface also provides a function called <code>select()</code> that manages a set of sockets. A call to <code>select()</code> returns information about which sockets have a packet waiting to be received and which sockets have room to accept a packet to be sent. The use of <code>select()</code> eliminates the polling and busy waiting that would otherwise be necessary for network I/O.</p>\n</blockquote>\n<p>假设一个进程同时见识多个设备，如果<code>read(设备1)</code> 是阻塞的，那么只要设备1没有数据到达，就会一直阻</p>\n<p>塞在设备1的read调用上，即使设备2有数据到达也不能处理，使用非阻塞I/O就可以避免设备2得不到及时处理。</p>\n<p>非阻塞I/O有一个缺点，如果所有设备都一直没有数据到达，调用者需要反复查询做无用功，如果阻塞在那里系统可以调度执行其他进程，就不会做无用功了。<code>select()</code> 函数可以阻塞地同时监视多个设备，还可以设定阻塞等待的超市时间，从而解决了这个问题。</p>\n<p>python标准库提供I/O多路复用模块，包括基础的<code>select</code> 模块和高层的<code>selectors</code> 模块</p>\n<ol start=\"6\">\n<li>附录</li>\n</ol>\n<ul>\n<li>进程的阻塞：<br>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。当进程调用一个阻塞（Block）的系统函数时，该进程被置于睡眠状态，这时内核调度其他进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep制定的睡眠时间到了）它才有可能继续运行。与睡眠状态相对的是运行状态，在linux内核中处于运行状态的进程分为两种情况：正在被调用执行和就绪状态。<br><img src=\"/../images/%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpeg\" alt=\"进程模型\"></li>\n<li>Unix/Linux下可用的5种I/O模型：<ul>\n<li>阻塞I/O</li>\n<li>非阻塞I/O</li>\n<li>I/O多路复用 (select, poll)</li>\n<li>信号驱动I/O (SIGIO)</li>\n<li>异步I/O</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Reference：\"><a href=\"#Reference：\" class=\"headerlink\" title=\"Reference：\"></a>Reference：</h1><p>[1] <a href=\"https://www.cnblogs.com/jiangzhaowei/p/8261174.html\">Linux的SOCKET编程详解</a></p>\n<p>[2] <a href=\"https://www.jianshu.com/p/4d0fab3fed16?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation\">Python——Socket编程</a></p>\n<p>[3] <a href=\"https://www.jianshu.com/p/9207700ec26d\">Python Socket编程</a></p>\n<p>[4] <a href=\"https://keelii.gitbooks.io/socket-programming-in-python-cn/content/\">Python中的Socket编程</a></p>\n<p>[5] <a href=\"https://segmentfault.com/a/1190000003063859#articleHeader6\">Linux IO模式及select, poll, epoll详解</a></p>\n","tags":["computer networking","TCP/IP","计算机网络"]},{"title":"字符串trick","url":"/2021/05/03/string-tricks/","content":"<h2 id=\"字符串-trick\"><a href=\"#字符串-trick\" class=\"headerlink\" title=\"字符串 trick\"></a>字符串 trick</h2><p>分享个字母大小写转换的方法：</p>\n<ol>\n<li>统一转成大写：<code>ch &amp; 0b11011111</code> 简写：<code>ch &amp; 0xDF</code></li>\n<li>统一转成小写：<code>ch | 0b00100000</code> 简写：<code>ch | 0x20</code></li>\n<li>大小写互换：<code>ch …… 0b00100000</code> 简写：<code>ch ^ 0x20</code>，原来是小写转成大写，原来是大写则转成小写</li>\n</ol>\n<p>比较的时候注意加上小括号哦，因为位运算优先级比较低。</p>\n<p>原理：65～90为26个大写英文字母，97～122号为26个小写英文字母</p>\n<p>65（0100 0001）到 90（0101 1010），刚好第5位（从0开始）都为0 </p>\n<p>97（0110 0001）到 122（0111 1010），刚好第5位（从0开始）都为1</p>\n<p>说明： <code>ch &amp; 0b11011111</code> ，效果就是将第5位（从0开始）清0，即如果第5位原来为0（大写字母），则保持不变，否则，减去32（小写转大写），小写字母转换成对应的大写字母正好就是减32</p>\n<p>同理，<code>ch | 0b00100000</code>，效果是如果第5位（从0开始）为0（大写字母），则加32，否（大写转小写）则，保持不变</p>\n","tags":["string"]},{"title":"字符编码","url":"/2020/02/17/unicode/","content":"<h1 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h1><h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>计算机不能直接识别字符（文本的最小组成单位）。<br>抽象字符和数字成对编码用于在计算机系统中表示的信息单位。虽然字符本身是抽象的，但它一旦存在与计算机系统中，它就对应了某种特定字符编码方式。计算机可以识别二进制数，于是采用一个二进制数来指代一个字符。</p>\n<h2 id=\"编码与解码\"><a href=\"#编码与解码\" class=\"headerlink\" title=\"编码与解码\"></a>编码与解码</h2><ul>\n<li>编码过程：字符转换成二进制刘表示的过程</li>\n<li>解码过程： 二进制刘转换成字符的过程</li>\n<li>编码规则：编码和解码过程中遵循的规则，例如GBK编码，UTF-8编码</li>\n</ul>\n<p>区分几个基本概念：</p>\n<p>字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。字符集是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集有：ASCII字符集、ISO 8859字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>\n<p>编码(encoding)和字符集不同。字符集只是字符的集合，不一定适合作网络传送、处理，有时须经编码(encode)后才能应用。如Unicode可依不同需要以UTF-8、UTF-16、UTF-32等方式编码。字符编码就是以二进制的数字来对应字符集的字符。使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。</p>\n<p>各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p>\n<p>注意：Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；大多数MBCS（包括GB2312）也只有一种。</p>\n<h2 id=\"字符编码的历史\"><a href=\"#字符编码的历史\" class=\"headerlink\" title=\"字符编码的历史\"></a>字符编码的历史</h2><h3 id=\"ASCII\"><a href=\"#ASCII\" class=\"headerlink\" title=\"ASCII\"></a>ASCII</h3><p>美国信息交换标准代码，最早的通用编码方案。开始时，只用7个比特位就表示完了所用拉丁文子没有和一些符号，共128个。后来发现不够用，又启用了第8位，刚好一个字节的长度，共256个字符。</p>\n<p>但是，不同的公司/组织吧这拓展出来的128个码位指派给了不同的字符，文档交流就困难了。于是ANSI这个组织站出来了，制定了ANSI标准。</p>\n<p>而且人们也发现，ASCII这种单字节（因为它占8个比特位）编码满足不了更多的字符需求，那必须得用多个字节编码。多字节字符集（MBCS）概念就诞生了。</p>\n<h3 id=\"ANSI\"><a href=\"#ANSI\" class=\"headerlink\" title=\"ANSI\"></a>ANSI</h3><p>美国国家标准协会认可的标准。注意，它是一种标准，而不是某种具体编码，可以看做是编码的一种分类。ANSI的标准就是，ASCII码占用的码位及其所指代的字符不许改变，剩下的自己扩展。</p>\n<p>中国人在这个规定上有自己的扩展（如GBK），英国人也有自己的扩展（如ISO-8859-1,即latin-1）。所以ISO-8859-1和GBK都可以称之为ANSI编码，因为它们符合ANSI规定。以Windows系统为例，中文系统中所指的ANSI编码就是GBK，英文系统中的ANSI编码就是ISO-8859-1。</p>\n<h3 id=\"MBCS\"><a href=\"#MBCS\" class=\"headerlink\" title=\"MBCS\"></a>MBCS</h3><p>多字节字符集(Multi-Byte Character Set)，采用不定长度可以是一个字节，也可以是两个字节，也可以是三个字节来进行编码。大多数情况下2个字节就够用了，汉字就分配两个字节，称之为DBCS（Double-Byte Chactacter Set）。</p>\n<p>在Linux系统中看得到MBCS说法，在Windows中呢？其实就是ANSI，ANSI只规定了第一个字节的位置是ASCII，超出这个范围的，肯定也是多字节的了。</p>\n<h2 id=\"Unicode字符集\"><a href=\"#Unicode字符集\" class=\"headerlink\" title=\"Unicode字符集\"></a>Unicode字符集</h2><p><em><strong>通过以上的介绍知道，各种解决方案都是各自为政，解决不了 “同一个系统中同时显示全宇宙的所有字符” 这个问题。</strong></em></p>\n<p>于是就有两个组织，他们开始着手做这件事情，UCS和Unicode诞生了。</p>\n<p>通用字符集（UCS，Universal Character Set）是由国际标准化组织（ISO）制定的 ISO 10646标准所定义的字符集。通常也译为通用多八位编码字符集。统一码（Unicode）是由统一码联盟指定的。</p>\n<p>后来发现，一山不容二虎，世界人民不需要两个目的相同但是具体实现却有差异的编码方案。UCS和Unicode握手言和，从 Unicode 2.0 起，采用了和ISO 10646-1的编码方案，它们在相同的码位上都对应同样的字符。尽管这两个组织目前还在相互独立的在发布字符编码标准。</p>\n<p>可能是Unicode名字好记，所以采用更为广泛。关于UCS-2，UCS-4这些概念不再赘述。</p>\n<h3 id=\"Unicode，UTF-8，UTF-16它们是什么关系\"><a href=\"#Unicode，UTF-8，UTF-16它们是什么关系\" class=\"headerlink\" title=\"Unicode，UTF-8，UTF-16它们是什么关系\"></a>Unicode，UTF-8，UTF-16它们是什么关系</h3><p>UTF-8（Unicode Transformation Format）即Unicode转换格式，8的意思是使用8比特为单位来进行编码。码位小于128时，就是对应的字节值；大于等于128时，就会转换成2、3、4字节的序列。每个字节的序列值介于128~255。</p>\n<p>GBK，GB2312，Latin-1，Big-5，ASCII等，它们的字符集和具体编码实现方式绑定（如GBK字符集就采用GBK编码方式），即字符和存储在介质上的二进制流一一对应。缺陷很明显，字符集扩展性差。Unicode考虑了这个问题，所以它的编码与编码的实现方式没有绑定。而是有多种实现方式，如UTF-8，UTF-16，UTF-32。</p>\n<p>例如字符‘A’在Unicode中的编码是65，但存储在介质上时，二进制流的十六进制表示采用UTF-8时是0x41，而UTF-16大端模式是0x00 0x41。</p>\n<p>Reference:</p>\n<p><a href=\"https://www.cnblogs.com/williamjie/p/9268151.html\">深度剖析java编码</a></p>\n<p><a href=\"https://blog.51cto.com/polaris/377468\">字符编码详解——彻底理解掌握编码知识，“乱码”不复存在</a></p>\n","tags":["Unicode","编码","字符串"]},{"title":"Vim basic","url":"/2021/01/12/vim-basic/","content":"<ol>\n<li><p>vim系统剪切板<br>“+y 复制到系统clipboard<br>“+p clipboard粘贴到vim<br>在Ubuntu中使用vim, 发现无法使用系统clipboard，可能是缺少相关的包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install vim-scripts vim-gtk</span><br><span class=\"line\"><span class=\"comment\"># 检测vim是否支持system clipboard</span></span><br><span class=\"line\">vim --version | grep clipboard</span><br></pre></td></tr></table></figure></li>\n<li><p>Vim寄存器<br> <code>:help register</code>查看10类48个寄存器</p>\n</li>\n</ol>\n<ul>\n<li>a-z命名寄存器（26个）</li>\n<li><code>&quot;*, &quot;+, &quot;-</code> 选取拖放</li>\n<li><code>&quot;:</code> 只读，vim命令行</li>\n<li><code>&quot;/</code> 搜说模式寄存器</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference:\"></a>Reference:</h2><p><a href=\"https://blog.csdn.net/a3192048/article/details/88290444\">使用Vim寄存器</a></p>\n","tags":["vim"]},{"title":"AOSP 入门","url":"/2022/03/12/AOSP-1-intro/","content":"<h1 id=\"AOSP-入门\"><a href=\"#AOSP-入门\" class=\"headerlink\" title=\"AOSP 入门\"></a>AOSP 入门</h1><h3 id=\"源码下载\"><a href=\"#源码下载\" class=\"headerlink\" title=\"源码下载\"></a>源码下载</h3><h4 id=\"国内同步UTSC源\"><a href=\"#国内同步UTSC源\" class=\"headerlink\" title=\"国内同步UTSC源\"></a>国内同步UTSC源</h4><p>第一次同步数据量特别大，如果网络不稳定，中间失败就要从头再来了。所以我们提供了打包的 AOSP 镜像，为一个 tar 包，大约 16G（单文件 16G，注意你的磁盘格式要支持）。这样你 就可以通过 HTTP 的方式下载，该方法支持断点续传。</p>\n<p>下载地址 <a href=\"http://mirrors.ustc.edu.cn/aosp-monthly/\">http://mirrors.ustc.edu.cn/aosp-monthly/</a></p>\n<p>请注意对比 checksum。</p>\n<p>然后根据下文 已有仓库如何改用科大源 的方法更改同步地址。</p>\n<p>解压后用命令 repo sync 就可以把代码都 checkout 出来。</p>\n<p>Note: tar 包为定时从 <a href=\"https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/\">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/</a> 下载。</p>\n<h4 id=\"科学同步-googlesource\"><a href=\"#科学同步-googlesource\" class=\"headerlink\" title=\"科学同步 googlesource\"></a>科学同步 googlesource</h4><p>按照 Google 官方教程 <a href=\"https://source.android.com/source/downloading.html\">https://source.android.com/source/downloading.html</a></p>\n<p><code>https://android.googlesource.com/platform/manifest</code> </p>\n<p>具体做法摘录如下（以防墙抽风）：</p>\n<p>首先下载 repo 工具。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir ~/bin</span><br><span class=\"line\">PATH=~/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br></pre></td></tr></table></figure>\n\n<p>然后建立一个工作目录（名字任意）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir WORKING_DIRECTORY</span><br><span class=\"line\"><span class=\"built_in\">cd</span> WORKING_DIRECTORY</span><br></pre></td></tr></table></figure>\n\n<p>初始化仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">repo init</span><br></pre></td></tr></table></figure>\n\n<p>同步源码树（以后只需执行这条命令来同步）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">repo sync</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"AOSP源码导入Android-Studio\"><a href=\"#AOSP源码导入Android-Studio\" class=\"headerlink\" title=\"AOSP源码导入Android Studio\"></a>AOSP源码导入Android Studio</h3><p>AOSP源码顶级目录下运行以下命令，生成google推荐的Idegen工具的配置文件<code>android.ipr</code>和<code>android.iml</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> build/envsetup.sh <span class=\"comment\"># 在新终端下需要执行这一步</span></span><br><span class=\"line\">mmma development/tools/idegen</span><br><span class=\"line\">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>\n\n<p><strong>过滤一些模块</strong><br> 如果把Android所有的源码全部导入到IDE里面去，工程将会非常大，而且会很耗时间，那么我们就可以把不需要的模块给过滤掉。<br> 打开<code>android.iml</code>文件，加入以下代码，修改<code>excludeFolder</code>的配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/.repo&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/abi&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/frameworks/base/docs&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/art&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/bionic&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/bootable&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/build&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/cts&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/dalvik&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/developers&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/development&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/device&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/docs&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/external&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/hardware&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/kernel-3.18&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/libcore&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/libnativehelper&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/ndk&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/out&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/pdk&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/platform_testing&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/prebuilts&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/rc_projects&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/sdk&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/system&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/tools&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/trusty&quot;</span>/&gt;</span><br><span class=\"line\">&lt;excludeFolder url=<span class=\"string\">&quot;file://<span class=\"variable\">$MODULE_DIR</span>$/vendor&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就只导入了<code>frameworks</code>和<code>packages</code>的代码。</p>\n<p>AOSP工程项目很大，在导入源码到IDEA之前需要先修改IDEA的配置：<br> 修改内存大小：<br> 打开IDEA 菜单栏<code>Help</code> &gt;<code>Edit Custom VM Options</code>，添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms1g </span><br><span class=\"line\">-Xmx5g</span><br></pre></td></tr></table></figure>\n\n<p>修改文件大小限制，打开区分大小写选项:<br> 打开IDEA 菜单栏 <code>Help -&gt; Edit custom properties</code>， 添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">idea.max.intellisense.filesize=100000</span><br><span class=\"line\">idea.case.sensitive.fs=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>NOTE: 重启IDEA使配置生效</p>\n</blockquote>\n<p>用IDEA找到AOSP目录下的<code>development/tools/idegen/android.ipr</code>文件，打开AOSP工程，耐心等待，索引需要一定时间</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://lug.ustc.edu.cn/wiki/mirrors/help/aosp/\">AOSP(Android) 镜像使用帮助</a><br><a href=\"https://www.jianshu.com/p/3e322f20da5b\">AOSP Intellij IDE 导入源码阅读</a></p>\n","tags":["AOSP"]}]