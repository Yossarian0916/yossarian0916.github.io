<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yossarian0916.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="个人博客, 学习，记录">
<meta property="og:type" content="website">
<meta property="og:title" content="乱笔">
<meta property="og:url" content="https://yossarian0916.github.io/page/2/index.html">
<meta property="og:site_name" content="乱笔">
<meta property="og:description" content="个人博客, 学习，记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yossarian42">
<meta property="article:tag" content="yossarian42">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yossarian0916.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector.css" />
  <title>乱笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">乱笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2020/11/19/RMQ-ST-table/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/RMQ-ST-table/" class="post-title-link" itemprop="url">RMQ-ST-table</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-19 04:03:26" itemprop="dateCreated datePublished" datetime="2020-11-19T04:03:26+08:00">2020-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Range-Minimum-Maximum-Query-RMQ"><a href="#Range-Minimum-Maximum-Query-RMQ" class="headerlink" title="Range Minimum/Maximum Query (RMQ)"></a>Range Minimum/Maximum Query (RMQ)</h1><p>RMQ对于给定长度n的数列A，询问区间数列A在（i,j）内最大最小值。</p>
<p>解决方法：（A长度为n，q次查询）</p>
<ol>
<li>搜索    复杂度：O(n) - O(qn)</li>
<li>线段树   预处理：O(n) - 查询：O(qlogn)</li>
<li>Sparse table(ST) 预处理：O(nlogn) - 查询：O(q)</li>
</ol>
<h2 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h2><p>ST本质上是动态规划，适用的情况是数据不更新，因为更新需要重新建表，这种情况下就选择线段树啦。</p>
<p>复杂度：建表O(nlogn)，查询O(1)</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p><code>f[i][j]</code>保存每一块[i, i + $2^j$ - 1]的最大值，起点i、终点i + $2^j$ - 1共$2^j$个数</p>
<p>[i, i + $2^j$ - 1]可以拆分成等长的2块，[i, i + $2^{j-1}$ - 1]和[i + $2^{j-1}$, i + $2^j$ - 1]，递归结构显现，可以用DP啦</p>
<p><code>f[i][j]=max(f[i][j - 1], f[i + (1&lt;&lt;(j-1))][j - 1])</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// j上限设为20</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span>&lt;&lt;(j-<span class="number">1</span>)) &lt;= size; i++) &#123;</span><br><span class="line">        dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span>&lt;&lt;(j-<span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dp[i][0]</code>记录的是原来数组的值，<code>i</code>从1开始是为了query时候方便，不用再改写成从0开始的index</p>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p>[l, r]区间可以按照[i, i + $2^j$ - 1]的模式划分成2块，[l, l + $2^k$ - 1]和[r - $2^k$ + 1, r]，</p>
<p>其中k = $\lfloor log_2(r - l + 1)\rfloor$ 向下取整</p>
<p><img src="/2020/11/19/RMQ-ST-table/rmq_st_query.png" alt="query示意图"></p>
<p>2段小区间长度相等，记为len，证明小区间有重叠：</p>
<p>$\lfloor log_2(len)\rfloor$ &gt;= $log_2(len)$ - 1，所以$2^{\lfloor log_2(len)\rfloor}$ &gt;= len/2, 这样2段小区间便有了重叠，保证query操作的正确性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (<span class="keyword">int</span>) (Math.log(r - l + <span class="number">1</span>) / Math.log(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[l][k], dp[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2020/10/10/git-submodule/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/10/git-submodule/" class="post-title-link" itemprop="url">Git Submodule</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-10 12:54:36" itemprop="dateCreated datePublished" datetime="2020-10-10T12:54:36+08:00">2020-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Git-Submodule"><a href="#Git-Submodule" class="headerlink" title="Git Submodule"></a>Git Submodule</h1><p>有可能会将代码根据功能拆解成不同的子模块。主项目对子模块有依赖关系，却又并不关心子模块的内部开发流程细节。</p>
<p>这种情况下，通常不会把所有源码都放在同一个 Git 仓库中。</p>
<p>有一种比较简单的方式，是在当前工作目录下，将子模块文件夹加入到 <code>.gitignore</code> 文件内容中，这样主项目就能够无视子项目的存在。这样做有一个弊端就是，使用主项目的人需要有一个先验知识：需要在当前目录下放置一份某版本的子模块代码。</p>
<p>还有另外一种方式可供借鉴，可以使用 Git 的 <code>submodule</code> 功能</p>
<h3 id="1-创建submodule"><a href="#1-创建submodule" class="headerlink" title="1. 创建submodule"></a>1. 创建submodule</h3><p><code>git submodule add &lt;submodule_url&gt; &lt;directory&gt;</code>在项目中创建一个子模块</p>
<p>例如：在project目录下<code>git submodule add github.com/username/projectA moduleA</code></p>
<p>此时主项目仓库会多出两个文件：<code>.gitmodules</code>和<code>moduleA</code>, <code>.gitmodules</code>包含submodule的主要信息</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;ModuleA&quot;]</span><br><span class="line">path=moduleA</span><br><span class="line">url=github.com/username/projectA</span><br></pre></td></tr></table></figure>

<p><code>moduleA</code>文件记录子模块的commit id。父项目并不会记录submodule的文件变动，只是按照commit id指定子模块的git HEAD。所以<code>.gitmodules</code>和<code>moduleA</code>都是需要提交到父项目的远程仓库中去的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .gitmodules moduleA</span><br><span class="line">git commit -m <span class="string">&#x27;add submodule projectA&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-克隆带子模块的repo"><a href="#2-克隆带子模块的repo" class="headerlink" title="2. 克隆带子模块的repo"></a>2. 克隆带子模块的repo</h3><p>方法一：先clone父项目，再初始化submodule，最后更新submodule。初始化只做一次，之后每次只需要update。默认submodule不在任何分支上，它指向父项目保存的submodule commit id</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> github.com/username/project &amp;&amp; <span class="built_in">cd</span> project</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>

<p>方法二：带上参数<code>--recursive-submodules</code></p>
<p><code>git clone github.com/username/project --recursive-submodules</code></p>
<h3 id="3-修改submodule"><a href="#3-修改submodule" class="headerlink" title="3. 修改submodule"></a>3. 修改submodule</h3><p>修改子模块代码只对子模块的版本库产生影响，对父项目的版本库不会产生任何影响。在子项目中修改代码并提交，之后在父项目中便可以看到子项目的新提交，正常add，commit就好。如果父项目需要用到最新版本的子模块，我们需要更新<code>.gitmodules</code>中submodule commit id。</p>
<h3 id="4-更新submodule"><a href="#4-更新submodule" class="headerlink" title="4. 更新submodule"></a>4. 更新submodule</h3><p>子模块的默认分支不是master</p>
<p>方法一：先pull父项目，然后执行<code>git submodule update</code>，注意moduleA的分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">git pull</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>

<p>方法二：先进入子模块，然后切换到需要的分支，在子模块中pull</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> project/moduleA</span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure>

<h3 id="5-删除submodule"><a href="#5-删除submodule" class="headerlink" title="5. 删除submodule"></a>5. 删除submodule</h3><p>先unregister需要删除的子模块，之后可以<code>git-rm</code>移除子模块代码文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">git submodule deinit &lt;submodule-name&gt;</span><br><span class="line">git rm &lt;submodule-name&gt;</span><br><span class="line">git commit -m <span class="string">&#x27;delete submodule &lt;submodule-name&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>--force</code>选项会强制删除子模块，即便子模块已经有本地修改</p>
<p><code>.git/config</code>和<code>.gitmodules</code>中相应内容自动被删除。在之后的<code>git submodule</code>和<code>git submodule foreach</code>都会跳过unregister的子模块</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nicksheng/p/6201711.html">Git Submodule管理项目子模块</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87053283">Git中submodule的使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsgxeva/p/8540758.html">Git Submodule使用完整教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2020/07/15/josephus-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/15/josephus-problem/" class="post-title-link" itemprop="url">Josephus Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-15T00:00:00+08:00">2020-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Josephus-Problem"><a href="#Josephus-Problem" class="headerlink" title="Josephus Problem"></a>Josephus Problem</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Josephus problem (or Josephus permutation), 简单说，N个人围成一圈，从某一人（比如第k个）开始报数，报到m的人退出，如此循环，直到最后一个人</p>
<blockquote>
<p>People are standing in a circle waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed.</p>
</blockquote>
<h2 id="解法1-circular-linked-list"><a href="#解法1-circular-linked-list" class="headerlink" title="解法1: circular linked list"></a>解法1: circular linked list</h2><p>循环链表解法很直接，复杂度O(n)</p>
<p>每个Node就是问题中的一个人，数到谁就删除相应的Node，最后只剩一个Node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createCirLinkedList</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">     Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">     Node next = head;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">         Node tmp = <span class="keyword">new</span> Node(i);</span><br><span class="line">         next.next = tmp;</span><br><span class="line">         next = next.next;</span><br><span class="line">      &#125;</span><br><span class="line">      next.next = head;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* create circurlar linked list */</span></span><br><span class="line">     Node head = createCirLinkedList(N);</span><br><span class="line">     <span class="comment">/* remove node recursively */</span> </span><br><span class="line">     <span class="keyword">while</span> (head != head.next)&#123;</span><br><span class="line">         <span class="comment">/* move head point to the previous node before to-be-deleted node */</span></span><br><span class="line">         <span class="comment">/* head.next is the node to be deleted */</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++)&#123;</span><br><span class="line">             head = head.next;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print(head.next.data+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">         <span class="comment">/* remove the m-th node */</span></span><br><span class="line">         head.next = head.next.next;</span><br><span class="line">         head = head.next;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> head.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2-数学方法递推公式"><a href="#解法2-数学方法递推公式" class="headerlink" title="解法2: 数学方法递推公式"></a>解法2: 数学方法递推公式</h2><p>求Josephus的递推就比较有意思啦，正向不行，得反着来。所有人围成一个圆，整个序列从任意一点开始都可，0点（index是0）是谁都一样可以数下去。那么每轮都把上一次被删除的那个人的下一个位置作为新的0点，开始新一轮数数。这样子，每一轮都是重复一样的模式在数数，recursion来了。</p>
<p>$J(n)$表示n个人玩最后胜利者的编号（编号从0开始），按照这样设定初始条件$J(1) = 0$  </p>
<p>过程：</p>
<p>$J(n)$:</p>
<p>   编号m % ( n - 1 )出局，剩下的人组成一个新的环，从k = m % n开始</p>
<p>   0, 1, 2, 3, 4, …, k-2, <del>k-1,</del> k, k+1, k+2, k+3, k+4, …, n-1</p>
<p>$J(n-1)$:</p>
<p>   n-k, n-k+1, n-k+2,…, n-2,   0, 1, 2, 3, 4, …, n-k-1,</p>
<p>   编号做一下转换：</p>
<pre><code>        J(n)编号 --&gt; J(n-1)编号

               k --&gt; 0

             k+1 --&gt; 1

             k+2 --&gt; 2

                 ...

             k-2 --&gt; n-2

             k-1 --&gt; n-1
</code></pre>
<p>n个人玩J(n)时的序号转换成n-1个人玩J(n-1)的序号，这样之，当我们知道子问题J(n-1）的胜利者编号就可以转换成J(n)时的编号，J(1)-&gt;J(2)-&gt;…-&gt;J(n-1)-&gt;J(n), 递推公式就来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   J(n) &#x3D; (J(n-1) + k) % n, k &#x3D; m % n</span><br><span class="line">&#x3D;&gt; J(n) &#x3D; (J(n-1) + m % n) % n</span><br><span class="line">        &#x3D; (J(n-1) + m) % n</span><br></pre></td></tr></table></figure>

<p>递推公式:<br>J(1) = 0<br>J(n) = (J(n-1) + m) % n</p>
<h3 id="recursive"><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* index begin at 0 */</span></span><br><span class="line">     <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (recursiveSolve(N - <span class="number">1</span>, m) + m) % N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* when index begins at 1 */</span></span><br><span class="line"><span class="keyword">int</span> res = solve(N, m) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="iterative"><a href="#iterative" class="headerlink" title="iterative"></a>iterative</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* index begin at 0 */</span></span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">         res = (res + m) % i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* when index begin at 1 */</span></span><br><span class="line">     res = res + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Josephus_problem">Josephus problem wikipedia</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jclian91/p/8660123.html">Josephus Problem的详细算法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2020/04/01/java_io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/java_io/" class="post-title-link" itemprop="url">Java IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-01T00:00:00+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h1><p>I/O流 概念： 流数据从一端传到另一端</p>
<p>Java I/O流分为三大类：</p>
<ul>
<li>按照读写单元（bit or byte）：字节流，字符流</li>
<li>按照流的方向：输入流，输出流</li>
<li>按照功能分：节点流，处理流</li>
</ul>
<p>字节流和字符流：</p>
<ul>
<li>当我们读取文件然后再写入其他文件时，不用过多的关注读取的内容时，通常使用的是字节流，因为这相当于是在处理二进制文件。读取数据效率高，并且保持数据的完整性；当我们读取文件的内容，并对文件的内容进行加工时，通常使用字符流。</li>
</ul>
<p>节点流和处理流：</p>
<ul>
<li>节点流：即从特定的数据源读取写入数据</li>
<li>处理流：在已经存在的节点流或者处理流上，进行装饰提供更强大的读写功能<ol>
<li>缓冲流（Buffered）带缓冲区，在节点流上添加缓冲区（例如：<code>new BufferedInputStream(new FileInputStream())</code>），这样避免读取文件时，大量进行硬盘的读写，提高读写效率</li>
<li>转换流（StreamReader）即字节流和字符流的相互转换，比如：在进行读写字节流时，想调用读取字符流的函数，就可以通过转换流。<code>InputStreamReader in = new InputStreamReader(new InputStream())</code> <strong>注意只能字节流=&gt;字符流</strong></li>
<li>数据流（Data）当读取写入具体的数值数据时，<code>DataInputStream</code>可以让你从<code>InputStream</code>读取Java基本类型来代替原始字节。如果读取的数据是由大于一个字节的Java基本类型构成，如int，long，float，double等，那么用<code>DataInputStream</code>是很方便的。读取的时候记住先读先写的原则，顺序不能乱，因为Java基本类型都是大于一个字节的，顺序不对，读取出来会出现乱码。所以在用<code>DataInputStream</code>的时候要么为文件中的数据采用固定格式，要么将额外信息保存到文件中，以便解析的时候确定数据位置和类型使用。</li>
</ol>
</li>
</ul>
<h3 id="Java-IO类结构"><a href="#Java-IO类结构" class="headerlink" title="Java IO类结构"></a>Java IO类结构</h3><p><strong><code>InputStream, OutputSteam, Reader, Writer</code>都是抽象类</strong></p>
<p>贴张图：</p>
<p><img src="/../images/java_IO.jpeg"></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16558621/article/details/51377887">Java流机制详解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaoyanjun6/article/details/54292148">Java IO流学习总结一：输入输出流</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2020/03/05/java_generics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/java_generics/" class="post-title-link" itemprop="url">Java泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-05T00:00:00+08:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Java泛型-类型擦除"><a href="#Java泛型-类型擦除" class="headerlink" title="Java泛型 类型擦除"></a>Java泛型 类型擦除</h3><p>正确理解泛型概念的首要前提是理解类型擦除(type erasure)。Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成List。JVM看到的只是<code>List</code>，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</p>
<h3 id="Java泛型特性"><a href="#Java泛型特性" class="headerlink" title="Java泛型特性"></a>Java泛型特性</h3><ul>
<li><p>泛型类并没有自己独有的Class类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</p>
</li>
<li><p>静态变量是被泛型类的所有实例所共享的。对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是 <code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量。</p>
</li>
<li><p>泛型的类型参数不能用在Java异常处理的<code>catch</code>语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于JVM来说，它们都是<code> MyException</code>类型的。也就无法执行与异常对应的<code>catch</code>语句。</p>
<h4 id="不允许创建参数化类型数组"><a href="#不允许创建参数化类型数组" class="headerlink" title="不允许创建参数化类型数组"></a>不允许创建参数化类型数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>擦除之后，<code>table</code>的类型是<code>Pair[]</code>。可以把它转换为<code>Object[]</code>:<code>Object[] objarray = table;</code></p>
<p>数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个<code>ArrayStoreException</code>异常：<code>objarray[0] = &quot;hello&quot;; // Error--component tye is Pair</code></p>
<p>不过对于泛型类型， 擦除会使这种机制无效。</p>
<p><code>objarray[0] = new Pair&lt;Employee&gt;()</code>能够通过数组存储检查，不过仍会导致一个类型错误。</p>
<p>处于安全考虑呢，Java不允许创建参数化类型的数组。</p>
</li>
</ul>
<h3 id="Java泛型与C-模板-差异之处"><a href="#Java泛型与C-模板-差异之处" class="headerlink" title="Java泛型与C++模板 差异之处"></a>Java泛型与C++模板 差异之处</h3><p>“泛型编程”这个概念最早就是来源于C++当初设计STL时所引入的模板（Template），而为什么要引入模板呢，因为STL要完成这样一个目标：设计一套通用的，不依赖类型的，高效的的算法（例如<code>std::sort</code>）和数据结构（例如<code>std::list</code>）。关于通用性，运行时多态（Polymorphism）可以做到（例如很多高级语言的继承（Inheritance）机制，接口（Interface）机制），但是C++作为一门相对底层的语言，对运行效率的要求是很严格的，而运行时多态会影响效率（例如成员函数只有在运行时才知道调用哪个），所以设计STL的人就创造了一种编译时多态技术，即模板。</p>
<p>那什么又是编译时多态呢，简单点说就是让编译器帮我确定类型，我写程序时只要标记下这里我要用“某种类型”的对象，至于具体是什么类型我不关心，你编译器帮我确定，编译完成后在运行时绝对是类型确定的，这样就大大提高了运行效率，反之对编译就增加了很多工作，而且生成的目标代码也会大大增加。所以对C++来说，所谓“泛型（Generics）”，并不是说编译器不知道类型，而是针对程序员来说的，这也正是通用性的体现。</p>
<p>在 C++ 模板中，编译器使用提供的类型参数来扩充模板，因此，为 <code>List&lt;A&gt;</code> 生成的 C++ 代码不同于为 <code>List&lt;B&gt;</code> 生成的代码，<code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code> 实际上是两个不同的类。而 Java 中的泛型则以不同的方式实现，编译器仅仅对这些类型参数进行擦除和替换。类型 <code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 的对象共享相同的类，并且只存在一个 <code>ArrayList</code> 类</p>
<h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><ol>
<li>Java核心技术</li>
<li><a target="_blank" rel="noopener" href="https://codefine.site/1759.html">Java泛型：类型檫除、模板和泛型传递</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2020/02/17/unicode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/17/unicode/" class="post-title-link" itemprop="url">字符编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-17T00:00:00+08:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>计算机不能直接识别字符（文本的最小组成单位）。<br>抽象字符和数字成对编码用于在计算机系统中表示的信息单位。虽然字符本身是抽象的，但它一旦存在与计算机系统中，它就对应了某种特定字符编码方式。计算机可以识别二进制数，于是采用一个二进制数来指代一个字符。</p>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><ul>
<li>编码过程：字符转换成二进制刘表示的过程</li>
<li>解码过程： 二进制刘转换成字符的过程</li>
<li>编码规则：编码和解码过程中遵循的规则，例如GBK编码，UTF-8编码</li>
</ul>
<p>区分几个基本概念：</p>
<p>字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。字符集是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集有：ASCII字符集、ISO 8859字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>
<p>编码(encoding)和字符集不同。字符集只是字符的集合，不一定适合作网络传送、处理，有时须经编码(encode)后才能应用。如Unicode可依不同需要以UTF-8、UTF-16、UTF-32等方式编码。字符编码就是以二进制的数字来对应字符集的字符。使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。</p>
<p>各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p>
<p>注意：Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；大多数MBCS（包括GB2312）也只有一种。</p>
<h2 id="字符编码的历史"><a href="#字符编码的历史" class="headerlink" title="字符编码的历史"></a>字符编码的历史</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>美国信息交换标准代码，最早的通用编码方案。开始时，只用7个比特位就表示完了所用拉丁文子没有和一些符号，共128个。后来发现不够用，又启用了第8位，刚好一个字节的长度，共256个字符。</p>
<p>但是，不同的公司/组织吧这拓展出来的128个码位指派给了不同的字符，文档交流就困难了。于是ANSI这个组织站出来了，制定了ANSI标准。</p>
<p>而且人们也发现，ASCII这种单字节（因为它占8个比特位）编码满足不了更多的字符需求，那必须得用多个字节编码。多字节字符集（MBCS）概念就诞生了。</p>
<h3 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h3><p>美国国家标准协会认可的标准。注意，它是一种标准，而不是某种具体编码，可以看做是编码的一种分类。ANSI的标准就是，ASCII码占用的码位及其所指代的字符不许改变，剩下的自己扩展。</p>
<p>中国人在这个规定上有自己的扩展（如GBK），英国人也有自己的扩展（如ISO-8859-1,即latin-1）。所以ISO-8859-1和GBK都可以称之为ANSI编码，因为它们符合ANSI规定。以Windows系统为例，中文系统中所指的ANSI编码就是GBK，英文系统中的ANSI编码就是ISO-8859-1。</p>
<h3 id="MBCS"><a href="#MBCS" class="headerlink" title="MBCS"></a>MBCS</h3><p>多字节字符集(Multi-Byte Character Set)，采用不定长度可以是一个字节，也可以是两个字节，也可以是三个字节来进行编码。大多数情况下2个字节就够用了，汉字就分配两个字节，称之为DBCS（Double-Byte Chactacter Set）。</p>
<p>在Linux系统中看得到MBCS说法，在Windows中呢？其实就是ANSI，ANSI只规定了第一个字节的位置是ASCII，超出这个范围的，肯定也是多字节的了。</p>
<h2 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h2><p><em><strong>通过以上的介绍知道，各种解决方案都是各自为政，解决不了 “同一个系统中同时显示全宇宙的所有字符” 这个问题。</strong></em></p>
<p>于是就有两个组织，他们开始着手做这件事情，UCS和Unicode诞生了。</p>
<p>通用字符集（UCS，Universal Character Set）是由国际标准化组织（ISO）制定的 ISO 10646标准所定义的字符集。通常也译为通用多八位编码字符集。统一码（Unicode）是由统一码联盟指定的。</p>
<p>后来发现，一山不容二虎，世界人民不需要两个目的相同但是具体实现却有差异的编码方案。UCS和Unicode握手言和，从 Unicode 2.0 起，采用了和ISO 10646-1的编码方案，它们在相同的码位上都对应同样的字符。尽管这两个组织目前还在相互独立的在发布字符编码标准。</p>
<p>可能是Unicode名字好记，所以采用更为广泛。关于UCS-2，UCS-4这些概念不再赘述。</p>
<h3 id="Unicode，UTF-8，UTF-16它们是什么关系"><a href="#Unicode，UTF-8，UTF-16它们是什么关系" class="headerlink" title="Unicode，UTF-8，UTF-16它们是什么关系"></a>Unicode，UTF-8，UTF-16它们是什么关系</h3><p>UTF-8（Unicode Transformation Format）即Unicode转换格式，8的意思是使用8比特为单位来进行编码。码位小于128时，就是对应的字节值；大于等于128时，就会转换成2、3、4字节的序列。每个字节的序列值介于128~255。</p>
<p>GBK，GB2312，Latin-1，Big-5，ASCII等，它们的字符集和具体编码实现方式绑定（如GBK字符集就采用GBK编码方式），即字符和存储在介质上的二进制流一一对应。缺陷很明显，字符集扩展性差。Unicode考虑了这个问题，所以它的编码与编码的实现方式没有绑定。而是有多种实现方式，如UTF-8，UTF-16，UTF-32。</p>
<p>例如字符‘A’在Unicode中的编码是65，但存储在介质上时，二进制流的十六进制表示采用UTF-8时是0x41，而UTF-16大端模式是0x00 0x41。</p>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/9268151.html">深度剖析java编码</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/polaris/377468">字符编码详解——彻底理解掌握编码知识，“乱码”不复存在</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2019/12/24/linux_kernel_space/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/24/linux_kernel_space/" class="post-title-link" itemprop="url">Linux内核空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-24 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-24T00:00:00+08:00">2019-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux内核空间，用户空间"><a href="#Linux内核空间，用户空间" class="headerlink" title="Linux内核空间，用户空间"></a>Linux内核空间，用户空间</h1><p>用户界面是操作系统的外在表象，内核才是操作系统的内在核心。系统其他部分必须依靠内核这部分软件提供的服务，像管理硬件设备、分配系统资源等。内核有时候被称作是管理者或者是操作系统核心。通常一个内核由负责响应中断的中断服务程序、负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。对于提供保护机制的现代系统来说，内核独立于普通应用程序，他一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和被保护起来的内存空间，统称为内核空间。相对的，应用程序在用户空间执行。它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划给别人的内存范围，还有其他一些使用限制。当内核运行的时候，系统以内核态进入内核空间执行。而执行一个普通用户程序时，系统将以用户态进入用户空间执行。</p>
<ol>
<li><p>用户空间、内核空间</p>
<p>现代操作系统都是采用虚拟存储器，对于32位操作系统，它的逻辑内存（虚拟存储空间）为4G（2^32）。为了保护内核，将其与用户应用程序代码隔离开来，操作系统将逻辑内存划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用；将较低的3G字节（从0x00000000到0xBFFFFFFF）供用户进程使用。每个进程可以通过系统调用进入内核。</p>
<p><img src="/../images/linux%E7%B3%BB%E7%BB%9F4G%E9%80%BB%E8%BE%91%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D.png" alt="linux系统4G逻辑内存空间分配"></p>
<p>内核空间存放linux内核代码和数据，用户空间存放的是用户的程序代码和数据。Linux只使用Intel的Ring0和Ring3两级保护机制（Ring0供内核使用，Ring3供用户空间使用）</p>
<p><img src="/../images/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="linux操作系统内部结构"></p>
<p><strong>但一个进程执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）</strong>。此时内核正在代其执行，在这种情况下，进程被称为通过系统调用在内核空间运行，而内核被称为运行于进程上下文中。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p><strong>当进程在执行用户程序代码时，则称其处于用户运行态（用户态）</strong>。</p>
</li>
<li><p>进程上下文，中断上下文<br>上下文（context）简单来说就是一个环境。对于进程来说就是进程执行时的环境。<br>用户空间的程序通过系统调用进入内核空间。这个时候用户空间的进程要传递很多变量、参数给内核，内核态运行的时候也要保存用户进程的一些寄存器的值、变量等。相对于进程而言，具体就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分：用户级上下文、寄存器上下文以及系统上下文。</p>
<ul>
<li>用户级上下文：正文、数据、用户堆栈以及共享存储器；</li>
<li>寄存器上下文：通用寄存器、程序寄存器、处理器状态寄存器、栈指针；</li>
<li>系统级上下文：进程控制块（task_struct)、内存管理信息（mm_struct, vm_area_struct, pgd, pte）、内核栈<br>当发生进程调度时，进行进程切换就是上下文切换（context switch）。操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换（mode switch），模式切换相较于进程切换，容易很多，而且节省时间，因为模式切换最主要的任务时切换进程寄存器。</li>
</ul>
<p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通多这些参数进行中断处理。所谓中断上下文，其实也可以看作硬件传递过来的参数和内核需要保存的一些环境。中断时，内核不代替任何进程运行，而是执行中断处理，与之没有进程相关联，也就没有进程上下文。内核运行与中断上下文时，不会被阻塞，因为此时没有与之关联的进程上下文，也就没有进程。</p>
</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><p>Linux内核设计与实现（第三版）<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3269106.html">用户空间与内核空间，进程上下文与中断上下文</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2019/11/10/linux_structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/linux_structure/" class="post-title-link" itemprop="url">Linux系统结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-10T00:00:00+08:00">2019-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux系统结构"><a href="#Linux系统结构" class="headerlink" title="Linux系统结构"></a>Linux系统结构</h1><p>Linux系统有4个主要部分：内核，shell，文件系统和应用程序。内核，shell和文件系统一起形成了基本的操作系统，它们使用户可以运行程序、管理文件并使用系统。</p>
<p><img src="/../images/linux_structure.png" alt="linux structure"></p>
<hr>
<ol>
<li><p>Linux内核</p>
<p>内核是操作系统的核心，负责管理系统的进程、内存、设备驱动程序、文件和网络系统。</p>
<p><img src="/../images/linux_kernel.jpg" alt="linux_kernel"></p>
<p>**系统调用接口: **SCI层提供了某些机制执行从用户空间到内核的函数调用。SCI实际上是一个非常有用的函数调用多路复用和多路分解服务。</p>
<ul>
<li><p>内存管理</p>
<p>Linux采用了虚拟内存的内存管理方式。Linux将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是4KB）。Linux包括了管理内存的方式，以及物理和虚拟映射所使用的硬件机制。</p>
<p>不过内存管理要管理的可不止4KB缓冲区。Linux提供了对4KB缓冲区的抽象。这种内存管理模式使用4KB缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。</p>
<p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。因此，页面可以一处内存并放入磁盘中。这个过程称为交换，因为页面会从内存交换到硬盘上。</p>
</li>
<li><p>进程管理</p>
<p>进程实际是某个特定应用程序的一个运行实体。在Linux系统中，能够同时运行多个进程，Linux通过在短时间间隔内轮流运行这些进程而实现“多任务”。这一短时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度”。</p>
<p>进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其他资源，着该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。</p>
<p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且</p>
</li>
<li><p>文件系统</p>
</li>
<li><p>设备驱动程序</p>
</li>
<li><p>网络接口（NET）</p>
</li>
</ul>
<hr>
</li>
<li><p>Linux Shell</p>
<p>…</p>
<hr>
</li>
<li><p>Linux文件系统</p>
<p>…</p>
<hr>
</li>
<li><p>应用程序</p>
<p>Linux系统一般都有一套称为应用程序的程序集，包括文本编辑器、编程语言、x window、Internet工具和数据库等。</p>
<hr>
</li>
<li><p>内核参数</p>
<p>Linux内核提供了一种通过/proc文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p>
<p>用户和应用程序可以通过/proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取/proc文件时，/proc文件系统是动态从系统内核读出所需信息并提交的。在/proc下有三个很重要的目录：/net，/scsi和/sys。/sys目录是可写的，可一通过它来访问或修改内核的参数，而/net和/scsi则依赖于内核配置。例如，如果系统不支持scsi，则scsi目录不存在。</p>
<p>除了这些，还有一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在/proc下，以进程的PID为目录名，它们是读取进程信息的接口。而/self目录则是读取进程本身的信息接口，是一个link，不同进程访问该目录是获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self来获取自己的系统信息，而不用每次都获取pid。</p>
</li>
</ol>
<p>Reference:</p>
<p>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/hguisu/article/details/6122513#t7">Linux系统结构 详解</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://blog.csdn.net/zdwzzu2006/article/details/7747977">Linux下/proc目录简介</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2019/10/05/GPU%E5%8A%A0%E9%80%9F%E7%89%88TensorFlow%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/05/GPU%E5%8A%A0%E9%80%9F%E7%89%88TensorFlow%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">tensorflow-gpu installation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-05T00:00:00+08:00">2019-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GPU加速版TensorFlow安装踩坑记录"><a href="#GPU加速版TensorFlow安装踩坑记录" class="headerlink" title="GPU加速版TensorFlow安装踩坑记录"></a>GPU加速版TensorFlow安装踩坑记录</h2><p>System information:</p>
<ul>
<li><p>Ubuntu 18.04 LTS</p>
</li>
<li><p>TensorFlow version: 1.13</p>
</li>
<li><p>Python version: 3.6</p>
</li>
<li><p>CUDA: 10.0</p>
</li>
<li><p>cuDNN: 7.4</p>
</li>
<li><p>GPU: Nvidia GeForce GTX 1050</p>
</li>
</ul>
<ol>
<li><p>千万提前确定好需要使用的tensorflow版本，再下载版本匹配的CUDA, cuDNN</p>
<p>幸好TensorFlow已经帮我们测试好了，在官网可以轻松找到推荐的<a target="_blank" rel="noopener" href="https://www.tensorflow.org/install/source#tested_build_configurations">构建配置</a>。因为我平时都在用Ubuntu18.04，在这把Linux平台上合适的配置放出来</p>
<p><img src="/../images/TensorFlow-linux-%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE.png" alt="Linux平台构建配置"></p>
</li>
<li><p>确定好构建配置，这一步可以<a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-toolkit-archive">下载CUDA</a>和<a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN</a>了</p>
<p>CUDA安装指令在官网已经详细贴出来，我就不再重复（真正的坑在安装cuDNN的时候等着呢）</p>
<p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/sdk/cudnn-install/index.html#installlinux">安装cuDNN</a>（这里还是以Linux平台为例）：</p>
<ul>
<li><p>下载cuDNN需要先注册</p>
</li>
<li><p>解压tar包，先修改tar包文件权限</p>
<p><code>$sudo chmod +x cudnn-10.0-linux-x64-v7.4.2.tgz</code></p>
<p><code>$tar -xzvf cudnn-10.0-linux-x64-v7.4.2.24.tgz</code></p>
</li>
<li><p>复制下列文件到CUDA Toolkit的文件夹，修改这些文件权限</p>
<p>一般CUDA Toolkit会自动安装在<code>/usr/local</code>下面</p>
<p><code>$sudo cp cuda/include/cudnn.h /usr/local/cuda/include</code></p>
<p><code>$sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64</code></p>
<p><code>$sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</code></p>
</li>
</ul>
</li>
<li><p>全部安装好后，检查版本是否正确</p>
<ul>
<li><p>CUDA版本</p>
<p><code>$cat /usr/local/cuda/version.txt</code> 或者<code>nvcc --version</code></p>
</li>
<li><p>cuDNN版本</p>
<p><code>$cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</code></p>
<p>ps: 有时候遇到<code>failed call to cuInit: CUDA_ERROR_UNKNOWN: unknown error</code>需要重启电脑</p>
</li>
</ul>
</li>
<li><p>最后的最后，检查TensorFlow是否能使用GPU加速</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.client <span class="keyword">import</span> device_lib</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># list the avilable devices in local processes</span></span><br><span class="line">device_lib.list_local_devices()</span><br><span class="line"></span><br><span class="line"><span class="comment"># matrix multiplying with GPU</span></span><br><span class="line">a = tf.constant([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], shape=[<span class="number">2</span>, <span class="number">3</span>], name=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">b = tf.constant([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], shape=[<span class="number">3</span>, <span class="number">2</span>], name=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">c = tf.matmul(a, b)</span><br><span class="line"></span><br><span class="line">sess = tf.Session(config=tf.ConfigProto(log_device_placement=<span class="literal">True</span>))</span><br><span class="line">print(sess.run(c))</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yossarian0916.github.io/2019/08/16/socket_programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yossarian42">
      <meta itemprop="description" content="个人博客, 学习，记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱笔">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/16/socket_programming/" class="post-title-link" itemprop="url">Socket编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-16 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-16T00:00:00+08:00">2019-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-16 00:07:21" itemprop="dateModified" datetime="2021-08-16T00:07:21+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h1><ol>
<li>网络中进程间通信</li>
</ol>
<p>进程通信的概念最初来自于单机系统。网络间进程通信要解决的是不同主机进程间的相互通信问题（可把统计进程通信看做是其中的特列）。首先需要解决的是网络间进程标识的问题。同一主机上，不同进程可以用进程号（PID）来区分。但在局域网中，各主机独立分配进程号，不同主机不同基层可能拥有相同的进程号，所以无法用来唯一标识。</p>
<p>TCP/IP协议族可以解决这个问题，网络层的”ip地址“可以唯一标识网络中的主机，而传输层的”协议+端口号“可以唯一标识主机中的进程。这样一个三元组（IP地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标识与其他进程交互。</p>
<p>使用TCP/IP协议的程序通常采用应用编程接口：UNIX BSD的套接字（socket）来实现网络进程之间的通信。</p>
<ol start="2">
<li>socket套接字</li>
</ol>
<p>socket起源于Unix，而Unix基本哲学之一就是”一切皆文件“， 都可以用”open -&gt; write/read -&gt; close“模式来操作。socket就是该模式的一个实现。socket即是一种特殊的文件，一些socket函数就是对其进行的操作。</p>
<p>socket是在应用层与TCP/IP之间的一个软件抽象层次，准确的说，它是一个接口。在设计模式中，socket使用了门面模式（Facade pattern）。它将复杂的TCP/IP协议族隐藏在socket接口后面，对用户来说，一组简单的接口就是全部，让socket去组织数据。</p>
<p><img src="/../images/socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="socket通信"></p>
<ol start="3">
<li>客户端/服务器socket通信简单例子</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># create socket descriptor</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># connect with local loopback address</span></span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># receive message from server, and send message from console input</span></span><br><span class="line"><span class="comment"># close the socket until input &#x27;exit&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    msg = input(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    client.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)  <span class="comment"># backlog number</span></span><br><span class="line">print(<span class="string">&#x27;Waiting for connection...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># accept connection from client</span></span><br><span class="line"><span class="comment"># receive message from client and send a random integer back </span></span><br><span class="line"><span class="comment"># until receive &#x27;exit&#x27;, close the connection and wait for next one</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    conn.send(<span class="string">b&#x27;Welcome&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Connected with %s:%s&#x27;</span> % addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># simple way to unpack block</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.encode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">            conn.send(str(msg).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    conn.close()</span><br><span class="line">    print(<span class="string">&#x27;Connection from %s:%s closed\n&#x27;</span> % addr)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>Python socket编程</p>
<p>a. 创建socket描述符</p>
<p><code>socket.socket(address_family, socket_type, protocol)</code></p>
<p><code>address_family</code>选择协议族（都以AF_开头），决定地址格式。<code>socket_type</code>确定套接字的类型。<code>protocol</code>指定协议。</p>
<p>b. 链接<code>connect()</code></p>
<p>c. 监听<code>bind()</code></p>
<p><code>accept()</code></p>
<p>d. 接受<code>recv()</code> <code>recvfrom()</code> </p>
<p>e. 发送 <code>send()</code>  <code>sendto()</code></p>
</li>
<li><p>Unix/linux下网络处理多连接</p>
<p>解决多客户‘并发’的方式：</p>
<p>a. 多线程</p>
<p>每当有客户端连接，启动一个线程来处理客户端数据</p>
<p>b. 异步I/O</p>
<p><code>asyncio</code>库使用单线程来处理多任务, 使用事件循环来管理任务</p>
<p>c. I/O复用，同步非阻塞监听</p>
</li>
</ol>
<p>先来理解下复用这个概念，复用也就是共用的意思。比较形象的解释，先看在通信领域中的使用，在通信领域中为了充分利用网络连接的物理介质，往往在同一条网络链路上采用时分复用或者频分复用的技术使其在同一链路上传输多路信号。对于网络编程来说，客户端发来的请求服务端会产生一个进程来对其服务，每当来一个客户请求就产生一个进程来服务，然而进程不可能无限制的产生，因此为了解决大量客户端访问的问题，引入了I/O复用技术：一个进程可以同时对多个客户请求进行服务。也就是说I/O复用的介质是进程，复用一个进程来对多个I/O进行服务，虽然客户端发来的I/O是并发的，但是I/O所需的读写数据多数情况下是没有准备好的，因此就可以利用<code>select</code>或者<code>poll</code> 来监听I/O所需的这些数据的状态，一旦I/O有数据可以进行读写了，进程就来对这样的I/O进行服务。</p>
<blockquote>
<p>To support the implementation of servers, the socket interface also provides a function called <code>select()</code> that manages a set of sockets. A call to <code>select()</code> returns information about which sockets have a packet waiting to be received and which sockets have room to accept a packet to be sent. The use of <code>select()</code> eliminates the polling and busy waiting that would otherwise be necessary for network I/O.</p>
</blockquote>
<p>假设一个进程同时见识多个设备，如果<code>read(设备1)</code> 是阻塞的，那么只要设备1没有数据到达，就会一直阻</p>
<p>塞在设备1的read调用上，即使设备2有数据到达也不能处理，使用非阻塞I/O就可以避免设备2得不到及时处理。</p>
<p>非阻塞I/O有一个缺点，如果所有设备都一直没有数据到达，调用者需要反复查询做无用功，如果阻塞在那里系统可以调度执行其他进程，就不会做无用功了。<code>select()</code> 函数可以阻塞地同时监视多个设备，还可以设定阻塞等待的超市时间，从而解决了这个问题。</p>
<p>python标准库提供I/O多路复用模块，包括基础的<code>select</code> 模块和高层的<code>selectors</code> 模块</p>
<ol start="6">
<li>附录</li>
</ol>
<ul>
<li>进程的阻塞：<br>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。当进程调用一个阻塞（Block）的系统函数时，该进程被置于睡眠状态，这时内核调度其他进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep制定的睡眠时间到了）它才有可能继续运行。与睡眠状态相对的是运行状态，在linux内核中处于运行状态的进程分为两种情况：正在被调用执行和就绪状态。<br><img src="/../images/%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpeg" alt="进程模型"></li>
<li>Unix/Linux下可用的5种I/O模型：<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O多路复用 (select, poll)</li>
<li>信号驱动I/O (SIGIO)</li>
<li>异步I/O</li>
</ul>
</li>
</ul>
<h1 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h1><p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangzhaowei/p/8261174.html">Linux的SOCKET编程详解</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d0fab3fed16?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">Python——Socket编程</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9207700ec26d">Python Socket编程</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://keelii.gitbooks.io/socket-programming-in-python-cn/content/">Python中的Socket编程</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859#articleHeader6">Linux IO模式及select, poll, epoll详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yossarian42</p>
  <div class="site-description" itemprop="description">个人博客, 学习，记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yossarian42</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
